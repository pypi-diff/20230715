# Comparing `tmp/netron-7.0.3-py3-none-any.whl.zip` & `tmp/netron-7.0.4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,146 +1,146 @@
-Zip file size: 1586347 bytes, number of entries: 144
--rw-r--r--  2.0 unx     1526 b- defN 23-Jul-08 02:03 netron/__init__.py
--rw-r--r--  2.0 unx    57889 b- defN 23-Jul-08 02:03 netron/acuity-metadata.json
--rw-r--r--  2.0 unx    24158 b- defN 23-Jul-08 02:03 netron/acuity.js
--rw-r--r--  2.0 unx    11340 b- defN 23-Jul-08 02:03 netron/armnn-metadata.json
--rw-r--r--  2.0 unx   108710 b- defN 23-Jul-08 02:03 netron/armnn-schema.js
--rw-r--r--  2.0 unx    13841 b- defN 23-Jul-08 02:03 netron/armnn.js
--rwxr-xr-x  2.0 unx    16619 b- defN 23-Jul-08 02:03 netron/barracuda.js
--rw-r--r--  2.0 unx    38147 b- defN 23-Jul-08 02:03 netron/base.js
--rw-r--r--  2.0 unx     2017 b- defN 23-Jul-08 02:03 netron/bigdl-metadata.json
--rw-r--r--  2.0 unx    24356 b- defN 23-Jul-08 02:03 netron/bigdl-proto.js
--rw-r--r--  2.0 unx    12793 b- defN 23-Jul-08 02:03 netron/bigdl.js
--rw-r--r--  2.0 unx    33634 b- defN 23-Jul-08 02:03 netron/browser.js
--rw-r--r--  2.0 unx     9505 b- defN 23-Jul-08 02:03 netron/caffe-metadata.json
--rw-r--r--  2.0 unx   188897 b- defN 23-Jul-08 02:03 netron/caffe-proto.js
--rw-r--r--  2.0 unx    25578 b- defN 23-Jul-08 02:03 netron/caffe.js
--rw-r--r--  2.0 unx   863689 b- defN 23-Jul-08 02:03 netron/caffe2-metadata.json
--rw-r--r--  2.0 unx    61210 b- defN 23-Jul-08 02:03 netron/caffe2-proto.js
--rw-r--r--  2.0 unx    22666 b- defN 23-Jul-08 02:03 netron/caffe2.js
--rw-r--r--  2.0 unx      902 b- defN 23-Jul-08 02:03 netron/cambricon.js
--rw-r--r--  2.0 unx    13245 b- defN 23-Jul-08 02:03 netron/circle-metadata.json
--rw-r--r--  2.0 unx    99313 b- defN 23-Jul-08 02:03 netron/circle-schema.js
--rw-r--r--  2.0 unx    24509 b- defN 23-Jul-08 02:03 netron/circle.js
--rw-r--r--  2.0 unx    14193 b- defN 23-Jul-08 02:03 netron/cntk-metadata.json
--rw-r--r--  2.0 unx    11578 b- defN 23-Jul-08 02:03 netron/cntk-proto.js
--rw-r--r--  2.0 unx    43823 b- defN 23-Jul-08 02:03 netron/cntk.js
--rw-r--r--  2.0 unx    15775 b- defN 23-Jul-08 02:03 netron/coreml-metadata.json
--rw-r--r--  2.0 unx   415701 b- defN 23-Jul-08 02:03 netron/coreml-proto.js
--rw-r--r--  2.0 unx    67891 b- defN 23-Jul-08 02:03 netron/coreml.js
--rw-r--r--  2.0 unx   102126 b- defN 23-Jul-08 02:03 netron/dagre.js
--rw-r--r--  2.0 unx    20570 b- defN 23-Jul-08 02:03 netron/darknet-metadata.json
--rw-r--r--  2.0 unx    54921 b- defN 23-Jul-08 02:03 netron/darknet.js
--rw-r--r--  2.0 unx     1417 b- defN 23-Jul-08 02:03 netron/dl4j-metadata.json
--rw-r--r--  2.0 unx    17000 b- defN 23-Jul-08 02:03 netron/dl4j.js
--rw-r--r--  2.0 unx      735 b- defN 23-Jul-08 02:03 netron/dlc-metadata.json
--rw-r--r--  2.0 unx     3277 b- defN 23-Jul-08 02:03 netron/dlc-schema.js
--rw-r--r--  2.0 unx    17868 b- defN 23-Jul-08 02:03 netron/dlc.js
--rw-r--r--  2.0 unx     1777 b- defN 23-Jul-08 02:03 netron/dnn-metadata.json
--rw-r--r--  2.0 unx    11533 b- defN 23-Jul-08 02:03 netron/dnn-proto.js
--rw-r--r--  2.0 unx    10601 b- defN 23-Jul-08 02:03 netron/dnn.js
--rw-r--r--  2.0 unx    34494 b- defN 23-Jul-08 02:03 netron/favicon.ico
--rw-r--r--  2.0 unx    11358 b- defN 23-Jul-08 02:03 netron/flatbuffers.js
--rw-r--r--  2.0 unx     7734 b- defN 23-Jul-08 02:03 netron/flax.js
--rw-r--r--  2.0 unx     7568 b- defN 23-Jul-08 02:03 netron/flexbuffers.js
--rw-r--r--  2.0 unx        3 b- defN 23-Jul-08 02:03 netron/flux-metadata.json
--rw-r--r--  2.0 unx     2409 b- defN 23-Jul-08 02:03 netron/flux.js
--rw-r--r--  2.0 unx     6061 b- defN 23-Jul-08 02:03 netron/grapher.css
--rw-r--r--  2.0 unx    25528 b- defN 23-Jul-08 02:03 netron/grapher.js
--rw-r--r--  2.0 unx    29456 b- defN 23-Jul-08 02:03 netron/hailo-metadata.json
--rw-r--r--  2.0 unx    11794 b- defN 23-Jul-08 02:03 netron/hailo.js
--rwxr-xr-x  2.0 unx    57289 b- defN 23-Jul-08 02:03 netron/hdf5.js
--rw-r--r--  2.0 unx     6797 b- defN 23-Jul-08 02:03 netron/hickle.js
--rw-r--r--  2.0 unx    58106 b- defN 23-Jul-08 02:03 netron/icon.png
--rw-r--r--  2.0 unx     1402 b- defN 23-Jul-08 02:03 netron/imgdnn.js
--rw-r--r--  2.0 unx    44030 b- defN 23-Jul-08 02:07 netron/index.html
--rw-r--r--  2.0 unx     3797 b- defN 23-Jul-08 02:03 netron/index.js
--rwxr-xr-x  2.0 unx    18643 b- defN 23-Jul-08 02:04 netron/json.js
--rw-r--r--  2.0 unx   254682 b- defN 23-Jul-08 02:04 netron/keras-metadata.json
--rw-r--r--  2.0 unx    52693 b- defN 23-Jul-08 02:04 netron/keras.js
--rw-r--r--  2.0 unx    64050 b- defN 23-Jul-08 02:04 netron/kmodel.js
--rw-r--r--  2.0 unx      244 b- defN 23-Jul-08 02:04 netron/lasagne-metadata.json
--rw-r--r--  2.0 unx     7059 b- defN 23-Jul-08 02:04 netron/lasagne.js
--rw-r--r--  2.0 unx     5169 b- defN 23-Jul-08 02:04 netron/lightgbm.js
--rw-r--r--  2.0 unx    12839 b- defN 23-Jul-08 02:04 netron/mediapipe.js
--rw-r--r--  2.0 unx    91710 b- defN 23-Jul-08 02:04 netron/megengine-metadata.json
--rw-r--r--  2.0 unx    82284 b- defN 23-Jul-08 02:04 netron/megengine-schema.js
--rw-r--r--  2.0 unx    32104 b- defN 23-Jul-08 02:04 netron/megengine.js
--rw-r--r--  2.0 unx    44765 b- defN 23-Jul-08 02:04 netron/mlir.js
--rw-r--r--  2.0 unx     3423 b- defN 23-Jul-08 02:04 netron/mlnet-metadata.json
--rw-r--r--  2.0 unx    78299 b- defN 23-Jul-08 02:04 netron/mlnet.js
--rw-r--r--  2.0 unx    10058 b- defN 23-Jul-08 02:04 netron/mnn-metadata.json
--rw-r--r--  2.0 unx    62288 b- defN 23-Jul-08 02:04 netron/mnn-schema.js
--rw-r--r--  2.0 unx    17641 b- defN 23-Jul-08 02:04 netron/mnn.js
--rw-r--r--  2.0 unx    85458 b- defN 23-Jul-08 02:04 netron/mslite-metadata.json
--rw-r--r--  2.0 unx   171745 b- defN 23-Jul-08 02:04 netron/mslite-schema.js
--rw-r--r--  2.0 unx    14997 b- defN 23-Jul-08 02:04 netron/mslite.js
--rw-r--r--  2.0 unx    11884 b- defN 23-Jul-08 02:04 netron/mxnet-metadata.json
--rw-r--r--  2.0 unx    37800 b- defN 23-Jul-08 02:04 netron/mxnet.js
--rw-r--r--  2.0 unx    30899 b- defN 23-Jul-08 02:04 netron/ncnn-metadata.json
--rw-r--r--  2.0 unx    38021 b- defN 23-Jul-08 02:04 netron/ncnn.js
--rw-r--r--  2.0 unx   290482 b- defN 23-Jul-08 02:04 netron/nnabla-metadata.json
--rw-r--r--  2.0 unx   434215 b- defN 23-Jul-08 02:04 netron/nnabla-proto.js
--rw-r--r--  2.0 unx    11415 b- defN 23-Jul-08 02:04 netron/nnabla.js
--rw-r--r--  2.0 unx     2221 b- defN 23-Jul-08 02:04 netron/nnef.js
--rw-r--r--  2.0 unx    15156 b- defN 23-Jul-08 02:04 netron/numpy.js
--rw-r--r--  2.0 unx    53079 b- defN 23-Jul-08 02:04 netron/om-metadata.json
--rw-r--r--  2.0 unx    37006 b- defN 23-Jul-08 02:04 netron/om-proto.js
--rw-r--r--  2.0 unx    31225 b- defN 23-Jul-08 02:04 netron/om.js
--rw-r--r--  2.0 unx     6818 b- defN 23-Jul-08 02:04 netron/onednn-metadata.json
--rw-r--r--  2.0 unx    12045 b- defN 23-Jul-08 02:04 netron/onednn.js
--rw-r--r--  2.0 unx  2898410 b- defN 23-Jul-08 02:04 netron/onnx-metadata.json
--rw-r--r--  2.0 unx    59899 b- defN 23-Jul-08 02:04 netron/onnx-proto.js
--rw-r--r--  2.0 unx    15717 b- defN 23-Jul-08 02:04 netron/onnx-schema.js
--rw-r--r--  2.0 unx    83595 b- defN 23-Jul-08 02:04 netron/onnx.js
--rw-r--r--  2.0 unx     9053 b- defN 23-Jul-08 02:04 netron/onnx.py
--rw-r--r--  2.0 unx    84585 b- defN 23-Jul-08 02:04 netron/openvino-metadata.json
--rw-r--r--  2.0 unx    44704 b- defN 23-Jul-08 02:04 netron/openvino.js
--rw-r--r--  2.0 unx     2894 b- defN 23-Jul-08 02:04 netron/paddle-metadata.json
--rw-r--r--  2.0 unx    60111 b- defN 23-Jul-08 02:04 netron/paddle-proto.js
--rw-r--r--  2.0 unx    19797 b- defN 23-Jul-08 02:04 netron/paddle-schema.js
--rw-r--r--  2.0 unx    37543 b- defN 23-Jul-08 02:04 netron/paddle.js
--rw-r--r--  2.0 unx     5535 b- defN 23-Jul-08 02:04 netron/pickle.js
--rw-r--r--  2.0 unx    42713 b- defN 23-Jul-08 02:04 netron/protobuf.js
--rw-r--r--  2.0 unx   303137 b- defN 23-Jul-08 02:04 netron/python.js
--rwxr-xr-x  2.0 unx   410224 b- defN 23-Jul-08 02:04 netron/pytorch-metadata.json
--rw-r--r--  2.0 unx    13170 b- defN 23-Jul-08 02:04 netron/pytorch-schema.js
--rw-r--r--  2.0 unx   182288 b- defN 23-Jul-08 02:04 netron/pytorch.js
--rw-r--r--  2.0 unx    24259 b- defN 23-Jul-08 02:04 netron/pytorch.py
--rw-r--r--  2.0 unx     5473 b- defN 23-Jul-08 02:04 netron/rknn-metadata.json
--rw-r--r--  2.0 unx     4263 b- defN 23-Jul-08 02:04 netron/rknn-schema.js
--rw-r--r--  2.0 unx    24814 b- defN 23-Jul-08 02:04 netron/rknn.js
--rw-r--r--  2.0 unx     4569 b- defN 23-Jul-08 02:04 netron/safetensors.js
--rw-r--r--  2.0 unx     5970 b- defN 23-Jul-08 02:04 netron/server.js
--rw-r--r--  2.0 unx    11874 b- defN 23-Jul-08 02:07 netron/server.py
--rw-r--r--  2.0 unx   160693 b- defN 23-Jul-08 02:04 netron/sklearn-metadata.json
--rw-r--r--  2.0 unx    14707 b- defN 23-Jul-08 02:04 netron/sklearn.js
--rw-r--r--  2.0 unx     4908 b- defN 23-Jul-08 02:04 netron/tar.js
--rwxr-xr-x  2.0 unx    27914 b- defN 23-Jul-08 02:04 netron/tengine-metadata.json
--rwxr-xr-x  2.0 unx    28124 b- defN 23-Jul-08 02:04 netron/tengine.js
--rw-r--r--  2.0 unx     5330 b- defN 23-Jul-08 02:04 netron/tensorrt.js
--rw-r--r--  2.0 unx    11085 b- defN 23-Jul-08 02:04 netron/text.js
--rw-r--r--  2.0 unx  2221625 b- defN 23-Jul-08 02:04 netron/tf-metadata.json
--rw-r--r--  2.0 unx   361929 b- defN 23-Jul-08 02:04 netron/tf-proto.js
--rw-r--r--  2.0 unx   106255 b- defN 23-Jul-08 02:04 netron/tf.js
--rw-r--r--  2.0 unx    29780 b- defN 23-Jul-08 02:04 netron/tflite-metadata.json
--rw-r--r--  2.0 unx   110995 b- defN 23-Jul-08 02:04 netron/tflite-schema.js
--rw-r--r--  2.0 unx    25211 b- defN 23-Jul-08 02:04 netron/tflite.js
--rw-r--r--  2.0 unx    20380 b- defN 23-Jul-08 02:04 netron/tnn-metadata.json
--rw-r--r--  2.0 unx    26885 b- defN 23-Jul-08 02:04 netron/tnn.js
--rw-r--r--  2.0 unx    12510 b- defN 23-Jul-08 02:04 netron/torch-metadata.json
--rw-r--r--  2.0 unx    41578 b- defN 23-Jul-08 02:04 netron/torch.js
--rw-r--r--  2.0 unx     2333 b- defN 23-Jul-08 02:04 netron/uff-metadata.json
--rw-r--r--  2.0 unx    30910 b- defN 23-Jul-08 02:04 netron/uff-proto.js
--rw-r--r--  2.0 unx    12802 b- defN 23-Jul-08 02:04 netron/uff.js
--rw-r--r--  2.0 unx   235596 b- defN 23-Jul-08 02:04 netron/view.js
--rw-r--r--  2.0 unx     8031 b- defN 23-Jul-08 02:04 netron/weka.js
--rw-r--r--  2.0 unx    64034 b- defN 23-Jul-08 02:04 netron/xml.js
--rw-r--r--  2.0 unx    55685 b- defN 23-Jul-08 02:04 netron/xmodel-proto.js
--rw-r--r--  2.0 unx    13916 b- defN 23-Jul-08 02:04 netron/xmodel.js
--rw-r--r--  2.0 unx    30503 b- defN 23-Jul-08 02:04 netron/zip.js
--rw-r--r--  2.0 unx     1576 b- defN 23-Jul-08 02:07 netron-7.0.3.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-08 02:07 netron-7.0.3.dist-info/WHEEL
--rw-r--r--  2.0 unx       39 b- defN 23-Jul-08 02:07 netron-7.0.3.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        7 b- defN 23-Jul-08 02:07 netron-7.0.3.dist-info/top_level.txt
--rw-rw-r--  2.0 unx    11131 b- defN 23-Jul-08 02:07 netron-7.0.3.dist-info/RECORD
-144 files, 12926734 bytes uncompressed, 1569655 bytes compressed:  87.9%
+Zip file size: 1588009 bytes, number of entries: 144
+-rw-r--r--  2.0 unx     1526 b- defN 23-Jul-15 04:23 netron/__init__.py
+-rw-r--r--  2.0 unx    57889 b- defN 23-Jul-15 04:23 netron/acuity-metadata.json
+-rw-r--r--  2.0 unx    24160 b- defN 23-Jul-15 04:23 netron/acuity.js
+-rw-r--r--  2.0 unx    11340 b- defN 23-Jul-15 04:23 netron/armnn-metadata.json
+-rw-r--r--  2.0 unx   108710 b- defN 23-Jul-15 04:23 netron/armnn-schema.js
+-rw-r--r--  2.0 unx    13844 b- defN 23-Jul-15 04:23 netron/armnn.js
+-rwxr-xr-x  2.0 unx    16619 b- defN 23-Jul-15 04:23 netron/barracuda.js
+-rw-r--r--  2.0 unx    38147 b- defN 23-Jul-15 04:23 netron/base.js
+-rw-r--r--  2.0 unx     2017 b- defN 23-Jul-15 04:23 netron/bigdl-metadata.json
+-rw-r--r--  2.0 unx    24356 b- defN 23-Jul-15 04:23 netron/bigdl-proto.js
+-rw-r--r--  2.0 unx    12793 b- defN 23-Jul-15 04:23 netron/bigdl.js
+-rw-r--r--  2.0 unx    33629 b- defN 23-Jul-15 04:23 netron/browser.js
+-rw-r--r--  2.0 unx     9505 b- defN 23-Jul-15 04:23 netron/caffe-metadata.json
+-rw-r--r--  2.0 unx   188897 b- defN 23-Jul-15 04:23 netron/caffe-proto.js
+-rw-r--r--  2.0 unx    25581 b- defN 23-Jul-15 04:23 netron/caffe.js
+-rw-r--r--  2.0 unx   863689 b- defN 23-Jul-15 04:23 netron/caffe2-metadata.json
+-rw-r--r--  2.0 unx    61210 b- defN 23-Jul-15 04:23 netron/caffe2-proto.js
+-rw-r--r--  2.0 unx    22669 b- defN 23-Jul-15 04:23 netron/caffe2.js
+-rw-r--r--  2.0 unx      902 b- defN 23-Jul-15 04:23 netron/cambricon.js
+-rw-r--r--  2.0 unx    13245 b- defN 23-Jul-15 04:23 netron/circle-metadata.json
+-rw-r--r--  2.0 unx    99313 b- defN 23-Jul-15 04:23 netron/circle-schema.js
+-rw-r--r--  2.0 unx    24512 b- defN 23-Jul-15 04:23 netron/circle.js
+-rw-r--r--  2.0 unx    14193 b- defN 23-Jul-15 04:23 netron/cntk-metadata.json
+-rw-r--r--  2.0 unx    11578 b- defN 23-Jul-15 04:23 netron/cntk-proto.js
+-rw-r--r--  2.0 unx    43826 b- defN 23-Jul-15 04:23 netron/cntk.js
+-rw-r--r--  2.0 unx    15775 b- defN 23-Jul-15 04:23 netron/coreml-metadata.json
+-rw-r--r--  2.0 unx   415701 b- defN 23-Jul-15 04:23 netron/coreml-proto.js
+-rw-r--r--  2.0 unx    67894 b- defN 23-Jul-15 04:23 netron/coreml.js
+-rw-r--r--  2.0 unx   102126 b- defN 23-Jul-15 04:23 netron/dagre.js
+-rw-r--r--  2.0 unx    20570 b- defN 23-Jul-15 04:23 netron/darknet-metadata.json
+-rw-r--r--  2.0 unx    54924 b- defN 23-Jul-15 04:23 netron/darknet.js
+-rw-r--r--  2.0 unx     1417 b- defN 23-Jul-15 04:23 netron/dl4j-metadata.json
+-rw-r--r--  2.0 unx    17003 b- defN 23-Jul-15 04:23 netron/dl4j.js
+-rw-r--r--  2.0 unx      735 b- defN 23-Jul-15 04:23 netron/dlc-metadata.json
+-rw-r--r--  2.0 unx     3277 b- defN 23-Jul-15 04:23 netron/dlc-schema.js
+-rw-r--r--  2.0 unx    17870 b- defN 23-Jul-15 04:23 netron/dlc.js
+-rw-r--r--  2.0 unx     1777 b- defN 23-Jul-15 04:23 netron/dnn-metadata.json
+-rw-r--r--  2.0 unx    11533 b- defN 23-Jul-15 04:23 netron/dnn-proto.js
+-rw-r--r--  2.0 unx    10601 b- defN 23-Jul-15 04:23 netron/dnn.js
+-rw-r--r--  2.0 unx    34494 b- defN 23-Jul-15 04:23 netron/favicon.ico
+-rw-r--r--  2.0 unx    11358 b- defN 23-Jul-15 04:23 netron/flatbuffers.js
+-rw-r--r--  2.0 unx     7734 b- defN 23-Jul-15 04:23 netron/flax.js
+-rw-r--r--  2.0 unx     7568 b- defN 23-Jul-15 04:23 netron/flexbuffers.js
+-rw-r--r--  2.0 unx        3 b- defN 23-Jul-15 04:23 netron/flux-metadata.json
+-rw-r--r--  2.0 unx     2409 b- defN 23-Jul-15 04:23 netron/flux.js
+-rw-r--r--  2.0 unx     6061 b- defN 23-Jul-15 04:23 netron/grapher.css
+-rw-r--r--  2.0 unx    25528 b- defN 23-Jul-15 04:23 netron/grapher.js
+-rw-r--r--  2.0 unx    29456 b- defN 23-Jul-15 04:23 netron/hailo-metadata.json
+-rw-r--r--  2.0 unx    11796 b- defN 23-Jul-15 04:23 netron/hailo.js
+-rwxr-xr-x  2.0 unx    57289 b- defN 23-Jul-15 04:23 netron/hdf5.js
+-rw-r--r--  2.0 unx     6799 b- defN 23-Jul-15 04:23 netron/hickle.js
+-rw-r--r--  2.0 unx    58106 b- defN 23-Jul-15 04:23 netron/icon.png
+-rw-r--r--  2.0 unx     1402 b- defN 23-Jul-15 04:23 netron/imgdnn.js
+-rw-r--r--  2.0 unx    44057 b- defN 23-Jul-15 04:26 netron/index.html
+-rw-r--r--  2.0 unx     4014 b- defN 23-Jul-15 04:23 netron/index.js
+-rwxr-xr-x  2.0 unx    18643 b- defN 23-Jul-15 04:23 netron/json.js
+-rw-r--r--  2.0 unx   254682 b- defN 23-Jul-15 04:23 netron/keras-metadata.json
+-rw-r--r--  2.0 unx    54590 b- defN 23-Jul-15 04:23 netron/keras.js
+-rw-r--r--  2.0 unx    64052 b- defN 23-Jul-15 04:23 netron/kmodel.js
+-rw-r--r--  2.0 unx      244 b- defN 23-Jul-15 04:23 netron/lasagne-metadata.json
+-rw-r--r--  2.0 unx     7061 b- defN 23-Jul-15 04:23 netron/lasagne.js
+-rw-r--r--  2.0 unx     5172 b- defN 23-Jul-15 04:23 netron/lightgbm.js
+-rw-r--r--  2.0 unx    12839 b- defN 23-Jul-15 04:23 netron/mediapipe.js
+-rw-r--r--  2.0 unx    91710 b- defN 23-Jul-15 04:23 netron/megengine-metadata.json
+-rw-r--r--  2.0 unx    82284 b- defN 23-Jul-15 04:23 netron/megengine-schema.js
+-rw-r--r--  2.0 unx    32109 b- defN 23-Jul-15 04:23 netron/megengine.js
+-rw-r--r--  2.0 unx    44765 b- defN 23-Jul-15 04:23 netron/mlir.js
+-rw-r--r--  2.0 unx     3423 b- defN 23-Jul-15 04:23 netron/mlnet-metadata.json
+-rw-r--r--  2.0 unx    78299 b- defN 23-Jul-15 04:23 netron/mlnet.js
+-rw-r--r--  2.0 unx    10058 b- defN 23-Jul-15 04:23 netron/mnn-metadata.json
+-rw-r--r--  2.0 unx    62288 b- defN 23-Jul-15 04:23 netron/mnn-schema.js
+-rw-r--r--  2.0 unx    17641 b- defN 23-Jul-15 04:23 netron/mnn.js
+-rw-r--r--  2.0 unx    85458 b- defN 23-Jul-15 04:23 netron/mslite-metadata.json
+-rw-r--r--  2.0 unx   171745 b- defN 23-Jul-15 04:23 netron/mslite-schema.js
+-rw-r--r--  2.0 unx    14997 b- defN 23-Jul-15 04:23 netron/mslite.js
+-rw-r--r--  2.0 unx    11884 b- defN 23-Jul-15 04:23 netron/mxnet-metadata.json
+-rw-r--r--  2.0 unx    37803 b- defN 23-Jul-15 04:23 netron/mxnet.js
+-rw-r--r--  2.0 unx    30899 b- defN 23-Jul-15 04:23 netron/ncnn-metadata.json
+-rw-r--r--  2.0 unx    38024 b- defN 23-Jul-15 04:23 netron/ncnn.js
+-rw-r--r--  2.0 unx   290482 b- defN 23-Jul-15 04:23 netron/nnabla-metadata.json
+-rw-r--r--  2.0 unx   434215 b- defN 23-Jul-15 04:23 netron/nnabla-proto.js
+-rw-r--r--  2.0 unx    11418 b- defN 23-Jul-15 04:23 netron/nnabla.js
+-rw-r--r--  2.0 unx     2224 b- defN 23-Jul-15 04:23 netron/nnef.js
+-rw-r--r--  2.0 unx    15163 b- defN 23-Jul-15 04:23 netron/numpy.js
+-rw-r--r--  2.0 unx    53079 b- defN 23-Jul-15 04:23 netron/om-metadata.json
+-rw-r--r--  2.0 unx    37006 b- defN 23-Jul-15 04:23 netron/om-proto.js
+-rw-r--r--  2.0 unx    31227 b- defN 23-Jul-15 04:23 netron/om.js
+-rw-r--r--  2.0 unx     6818 b- defN 23-Jul-15 04:23 netron/onednn-metadata.json
+-rw-r--r--  2.0 unx    12047 b- defN 23-Jul-15 04:23 netron/onednn.js
+-rw-r--r--  2.0 unx  2903924 b- defN 23-Jul-15 04:23 netron/onnx-metadata.json
+-rw-r--r--  2.0 unx    59899 b- defN 23-Jul-15 04:23 netron/onnx-proto.js
+-rw-r--r--  2.0 unx    15717 b- defN 23-Jul-15 04:23 netron/onnx-schema.js
+-rw-r--r--  2.0 unx    83598 b- defN 23-Jul-15 04:23 netron/onnx.js
+-rw-r--r--  2.0 unx     9053 b- defN 23-Jul-15 04:23 netron/onnx.py
+-rw-r--r--  2.0 unx    84585 b- defN 23-Jul-15 04:23 netron/openvino-metadata.json
+-rw-r--r--  2.0 unx    44609 b- defN 23-Jul-15 04:23 netron/openvino.js
+-rw-r--r--  2.0 unx     2894 b- defN 23-Jul-15 04:23 netron/paddle-metadata.json
+-rw-r--r--  2.0 unx    60111 b- defN 23-Jul-15 04:23 netron/paddle-proto.js
+-rw-r--r--  2.0 unx    19797 b- defN 23-Jul-15 04:23 netron/paddle-schema.js
+-rw-r--r--  2.0 unx    37551 b- defN 23-Jul-15 04:23 netron/paddle.js
+-rw-r--r--  2.0 unx     5537 b- defN 23-Jul-15 04:23 netron/pickle.js
+-rw-r--r--  2.0 unx    42713 b- defN 23-Jul-15 04:23 netron/protobuf.js
+-rw-r--r--  2.0 unx   303560 b- defN 23-Jul-15 04:23 netron/python.js
+-rwxr-xr-x  2.0 unx   410224 b- defN 23-Jul-15 04:23 netron/pytorch-metadata.json
+-rw-r--r--  2.0 unx    13170 b- defN 23-Jul-15 04:23 netron/pytorch-schema.js
+-rw-r--r--  2.0 unx   182217 b- defN 23-Jul-15 04:23 netron/pytorch.js
+-rw-r--r--  2.0 unx    24259 b- defN 23-Jul-15 04:23 netron/pytorch.py
+-rw-r--r--  2.0 unx     5473 b- defN 23-Jul-15 04:23 netron/rknn-metadata.json
+-rw-r--r--  2.0 unx     4263 b- defN 23-Jul-15 04:23 netron/rknn-schema.js
+-rw-r--r--  2.0 unx    24816 b- defN 23-Jul-15 04:23 netron/rknn.js
+-rw-r--r--  2.0 unx     4571 b- defN 23-Jul-15 04:23 netron/safetensors.js
+-rw-r--r--  2.0 unx     5972 b- defN 23-Jul-15 04:23 netron/server.js
+-rw-r--r--  2.0 unx    11874 b- defN 23-Jul-15 04:26 netron/server.py
+-rw-r--r--  2.0 unx   160693 b- defN 23-Jul-15 04:23 netron/sklearn-metadata.json
+-rw-r--r--  2.0 unx    14713 b- defN 23-Jul-15 04:23 netron/sklearn.js
+-rw-r--r--  2.0 unx     4908 b- defN 23-Jul-15 04:23 netron/tar.js
+-rwxr-xr-x  2.0 unx    27914 b- defN 23-Jul-15 04:23 netron/tengine-metadata.json
+-rwxr-xr-x  2.0 unx    28126 b- defN 23-Jul-15 04:23 netron/tengine.js
+-rw-r--r--  2.0 unx     5304 b- defN 23-Jul-15 04:23 netron/tensorrt.js
+-rw-r--r--  2.0 unx    11085 b- defN 23-Jul-15 04:23 netron/text.js
+-rw-r--r--  2.0 unx  2221625 b- defN 23-Jul-15 04:23 netron/tf-metadata.json
+-rw-r--r--  2.0 unx   361929 b- defN 23-Jul-15 04:23 netron/tf-proto.js
+-rw-r--r--  2.0 unx   106628 b- defN 23-Jul-15 04:23 netron/tf.js
+-rw-r--r--  2.0 unx    29780 b- defN 23-Jul-15 04:23 netron/tflite-metadata.json
+-rw-r--r--  2.0 unx   110995 b- defN 23-Jul-15 04:23 netron/tflite-schema.js
+-rw-r--r--  2.0 unx    25214 b- defN 23-Jul-15 04:23 netron/tflite.js
+-rw-r--r--  2.0 unx    20380 b- defN 23-Jul-15 04:23 netron/tnn-metadata.json
+-rw-r--r--  2.0 unx    26888 b- defN 23-Jul-15 04:23 netron/tnn.js
+-rw-r--r--  2.0 unx    12510 b- defN 23-Jul-15 04:23 netron/torch-metadata.json
+-rw-r--r--  2.0 unx    41580 b- defN 23-Jul-15 04:23 netron/torch.js
+-rw-r--r--  2.0 unx     2333 b- defN 23-Jul-15 04:23 netron/uff-metadata.json
+-rw-r--r--  2.0 unx    30910 b- defN 23-Jul-15 04:23 netron/uff-proto.js
+-rw-r--r--  2.0 unx    12805 b- defN 23-Jul-15 04:23 netron/uff.js
+-rw-r--r--  2.0 unx   235511 b- defN 23-Jul-15 04:23 netron/view.js
+-rw-r--r--  2.0 unx     8031 b- defN 23-Jul-15 04:23 netron/weka.js
+-rw-r--r--  2.0 unx    64034 b- defN 23-Jul-15 04:23 netron/xml.js
+-rw-r--r--  2.0 unx    55685 b- defN 23-Jul-15 04:23 netron/xmodel-proto.js
+-rw-r--r--  2.0 unx    13916 b- defN 23-Jul-15 04:23 netron/xmodel.js
+-rw-r--r--  2.0 unx    30755 b- defN 23-Jul-15 04:23 netron/zip.js
+-rw-r--r--  2.0 unx     1576 b- defN 23-Jul-15 04:26 netron-7.0.4.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-15 04:26 netron-7.0.4.dist-info/WHEEL
+-rw-r--r--  2.0 unx       39 b- defN 23-Jul-15 04:26 netron-7.0.4.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        7 b- defN 23-Jul-15 04:26 netron-7.0.4.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    11131 b- defN 23-Jul-15 04:26 netron-7.0.4.dist-info/RECORD
+144 files, 12935260 bytes uncompressed, 1571317 bytes compressed:  87.9%
```

## zipnote {}

```diff
@@ -411,23 +411,23 @@
 
 Filename: netron/xmodel.js
 Comment: 
 
 Filename: netron/zip.js
 Comment: 
 
-Filename: netron-7.0.3.dist-info/METADATA
+Filename: netron-7.0.4.dist-info/METADATA
 Comment: 
 
-Filename: netron-7.0.3.dist-info/WHEEL
+Filename: netron-7.0.4.dist-info/WHEEL
 Comment: 
 
-Filename: netron-7.0.3.dist-info/entry_points.txt
+Filename: netron-7.0.4.dist-info/entry_points.txt
 Comment: 
 
-Filename: netron-7.0.3.dist-info/top_level.txt
+Filename: netron-7.0.4.dist-info/top_level.txt
 Comment: 
 
-Filename: netron-7.0.3.dist-info/RECORD
+Filename: netron-7.0.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## netron/acuity.js

### js-beautify {}

```diff
@@ -9,17 +9,17 @@
             if (obj && obj.MetaData && obj.Layers) {
                 return obj;
             }
         }
         return null;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const metadata = await context.metadata('acuity-metadata.json');
-        return new acuity.Model(metadata, match);
+        return new acuity.Model(metadata, target);
     }
 };
 
 acuity.Model = class {
 
     constructor(metadata, model, data, quantization) {
         this._name = model.MetaData.Name;
```

## netron/armnn.js

### js-beautify {}

```diff
@@ -15,19 +15,19 @@
             if (obj && obj.layers && obj.inputIds && obj.outputIds) {
                 return 'armnn.flatbuffers.json';
             }
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         await context.require('./armnn-schema');
         armnn.schema = flatbuffers.get('armnn').armnnSerializer;
         let model = null;
-        switch (match) {
+        switch (target) {
             case 'armnn.flatbuffers': {
                 try {
                     const stream = context.stream;
                     const reader = flatbuffers.BinaryReader.open(stream);
                     model = armnn.schema.SerializedGraph.create(reader);
                 } catch (error) {
                     const message = error && error.message ? error.message : error.toString();
@@ -43,15 +43,15 @@
                 } catch (error) {
                     const message = error && error.message ? error.message : error.toString();
                     throw new armnn.Error('File text format is not armnn.SerializedGraph (' + message.replace(/\.$/, '') + ').');
                 }
                 break;
             }
             default: {
-                throw new armnn.Error("Unsupported Arm NN '" + match + "'.");
+                throw new armnn.Error("Unsupported Arm NN '" + target + "'.");
             }
         }
         const metadata = await context.metadata('armnn-metadata.json');
         return new armnn.Model(metadata, model);
     }
 };
```

## netron/browser.js

### js-beautify {}

```diff
@@ -173,28 +173,25 @@
         await age();
         await consent();
         await telemetry();
         await capabilities();
     }
 
     async start() {
-
         const hash = this.window.location.hash ? this.window.location.hash.replace(/^#/, '') : '';
         const search = this.window.location.search;
         const params = new URLSearchParams(search + (hash ? '&' + hash : ''));
-
         if (this._meta.file && this._meta.identifier) {
             const url = this._meta.file[0];
             if (this._view.accept(url)) {
                 this._openModel(this._url(url), null);
                 this._document.title = this._meta.identifier;
                 return;
             }
         }
-
         const url = params.get('url');
         if (url) {
             const identifier = params.get('identifier') || null;
             const location = url
                 .replace(/^https:\/\/github\.com\/([\w-]*\/[\w-]*)\/blob\/([\w/\-_.]*)(\?raw=true)?$/, 'https://raw.githubusercontent.com/$1/$2')
                 .replace(/^https:\/\/github\.com\/([\w-]*\/[\w-]*)\/raw\/([\w/\-_.]*)$/, 'https://raw.githubusercontent.com/$1/$2')
                 .replace(/^https:\/\/huggingface.co\/(.*)\/blob\/(.*)$/, 'https://huggingface.co/$1/resolve/$2');
@@ -202,21 +199,19 @@
                 const title = await this._openModel(location, identifier);
                 if (title) {
                     this.document.title = title;
                     return;
                 }
             }
         }
-
         const gist = params.get('gist');
         if (gist) {
             this._openGist(gist);
             return;
         }
-
         const openFileButton = this._element('open-file-button');
         const openFileDialog = this._element('open-file-dialog');
         if (openFileButton && openFileDialog) {
             openFileButton.addEventListener('click', () => {
                 this.execute('open');
             });
             const mobileSafari = this.environment('platform') === 'darwin' && navigator.maxTouchPoints && navigator.maxTouchPoints > 1;
@@ -247,15 +242,14 @@
                 const files = Array.from(e.dataTransfer.files);
                 const file = files.find((file) => this._view.accept(file.name, file.size));
                 if (file) {
                     this._open(file, files);
                 }
             }
         });
-
         this._view.show('welcome');
     }
 
     environment(name) {
         return this._environment[name];
     }
 
@@ -589,15 +583,15 @@
             const button = this._element('message-button');
             if (action) {
                 button.style.removeProperty('display');
                 button.innerText = action;
                 button.onclick = () => {
                     button.onclick = null;
                     this._document.body.classList.remove('message');
-                    resolve();
+                    resolve(0);
                 };
                 button.focus();
             } else {
                 button.style.display = 'none';
                 button.onclick = null;
             }
             this._document.body.classList.add('message');
```

## netron/caffe.js

### js-beautify {}

```diff
@@ -20,15 +20,15 @@
         }
         if (tags.has('net') || tags.has('train_net') || tags.has('net_param')) {
             return 'caffe.pbtxt.solver';
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         await context.require('./caffe-proto');
         caffe.proto = protobuf.get('caffe').caffe;
         const openModel = async (context, netParameter) => {
             const metadata = await context.metadata('caffe-metadata.json');
             return new caffe.Model(metadata, netParameter);
         };
         const openNetParameterText = (context, identifier, buffer) => {
@@ -81,15 +81,15 @@
                 netParameter = caffe.proto.NetParameter.decodeText(reader);
             } catch (error) {
                 const message = error && error.message ? error.message : error.toString();
                 throw new caffe.Error('File text format is not caffe.NetParameter (' + message.replace(/\.$/, '') + ').');
             }
             return openModel(context, netParameter);
         };
-        switch (match) {
+        switch (target) {
             case 'caffe.pbtxt.solver': {
                 const stream = context.stream;
                 const reader = protobuf.TextReader.open(stream);
                 reader.field = function(tag, message) {
                     if (message instanceof caffe.proto.SolverParameter) {
                         message[tag] = this.read();
                         return;
@@ -123,15 +123,15 @@
                 } catch (error) {
                     const message = error && error.message ? error.message : error.toString();
                     throw new caffe.Error('File format is not caffe.NetParameter (' + message.replace(/\.$/, '') + ').');
                 }
                 return openModel(context, netParameter);
             }
             default: {
-                throw new caffe.Error("Unsupported Caffe format '" + match + "'.");
+                throw new caffe.Error("Unsupported Caffe format '" + target + "'.");
             }
         }
     }
 
     static _decodeText(reader) {
         const message = {};
         reader.start();
```

## netron/caffe2.js

### js-beautify {}

```diff
@@ -50,22 +50,22 @@
             if (tags.has('op') && !tags.has('op.attr') && !tags.has('op.graph_op_name') && !tags.has('op.endpoint')) {
                 return 'caffe2.pbtxt';
             }
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         await context.require('./caffe2-proto');
         const metadata = await context.metadata('caffe2-metadata.json');
         const identifier = context.identifier;
         const parts = identifier.split('.');
         const extension = parts.pop().toLowerCase();
         const base = parts.join('.');
-        switch (match) {
+        switch (target) {
             case 'caffe2.pbtxt': {
                 const openText = (predictBuffer, initBuffer, initTextFormat) => {
                     let predict_net = null;
                     let init_net = null;
                     try {
                         caffe2.proto = protobuf.get('caffe2').caffe2;
                         const reader = protobuf.TextReader.open(predictBuffer);
@@ -184,15 +184,15 @@
                     const buffer = stream.read();
                     return openBinary(context.stream.peek(), buffer);
                 } catch (error) {
                     return openBinary(context.stream.peek(), null);
                 }
             }
             default: {
-                throw new caffe2.Error("Unsupported Caffe2 format '" + match + "'.");
+                throw new caffe2.Error("Unsupported Caffe2 format '" + target + "'.");
             }
         }
     }
 };
 
 caffe2.Model = class {
```

## netron/circle.js

### js-beautify {}

```diff
@@ -13,20 +13,20 @@
         const obj = context.open('json');
         if (obj && obj.subgraphs && obj.operator_codes) {
             return 'circle.flatbuffers.json';
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         await context.require('./circle-schema');
         circle.schema = flatbuffers.get('circle').circle;
         let model = null;
         const attachments = new Map();
-        switch (match) {
+        switch (target) {
             case 'circle.flatbuffers.json': {
                 try {
                     const obj = context.open('json');
                     const reader = new flatbuffers.TextReader(obj);
                     model = circle.schema.Model.createText(reader);
                 } catch (error) {
                     const message = error && error.message ? error.message : error.toString();
@@ -52,15 +52,15 @@
                     }
                 } catch (error) {
                     // continue regardless of error
                 }
                 break;
             }
             default: {
-                throw new circle.Error("Unsupported Circle format '" + match + "'.");
+                throw new circle.Error("Unsupported Circle format '" + target + "'.");
             }
         }
         const metadata = await context.metadata('circle-metadata.json');
         return new circle.Model(metadata, model);
     }
 };
```

## netron/cntk.js

### js-beautify {}

```diff
@@ -18,17 +18,17 @@
         const tags = context.tags('pb');
         if (tags.get(1) === 0 && tags.get(2) === 2) {
             return 'cntk.v2';
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const metadata = await context.metadata('cntk-metadata.json');
-        switch (match) {
+        switch (target) {
             case 'cntk.v1': {
                 let obj = null;
                 try {
                     const stream = context.stream;
                     const buffer = stream.peek();
                     obj = new cntk_v1.ComputationNetwork(buffer);
                 } catch (error) {
@@ -53,15 +53,15 @@
                 } catch (error) {
                     const message = error && error.message ? error.message : error.toString();
                     throw new cntk.Error('File format is not cntk.Dictionary (' + message.replace(/\.$/, '') + ').');
                 }
                 return new cntk.Model(metadata, 2, obj);
             }
             default: {
-                throw new cntk.Error("Unsupported CNTK format '" + match + "'.");
+                throw new cntk.Error("Unsupported CNTK format '" + target + "'.");
             }
         }
     }
 
     static _convertDictionary(dictionary) {
         const target = {};
         for (const key of Object.keys(dictionary.data).filter((key) => key != 'version')) {
```

## netron/coreml.js

### js-beautify {}

```diff
@@ -59,15 +59,15 @@
                     return 'coreml.weights';
                 }
             }
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         await context.require('./coreml-proto');
         const metadata = await context.metadata('coreml-metadata.json');
         const openModel = async (stream, context, path, format) => {
             let model = null;
             try {
                 coreml.proto = protobuf.get('coreml').CoreML.Specification;
                 const reader = protobuf.BinaryReader.open(stream);
@@ -142,15 +142,15 @@
         };
         const openManifestStream = async (context, path) => {
             const stream = await context.request(path + 'Manifest.json', null);
             const reader = json.TextReader.open(stream);
             const obj = reader.read();
             return openManifest(obj, context, path);
         };
-        switch (match) {
+        switch (target) {
             case 'coreml.pb': {
                 return openModel(context.stream, context, context.identifier);
             }
             case 'coreml.manifest': {
                 const obj = context.open('json');
                 return openManifest(obj, context, '');
             }
@@ -158,15 +158,15 @@
             case 'coreml.metadata': {
                 return openManifestStream(context, '../../');
             }
             case 'coreml.weights': {
                 return openManifestStream(context, '../../../');
             }
             default: {
-                throw new coreml.Error("Unsupported Core ML format '" + match + "'.");
+                throw new coreml.Error("Unsupported Core ML format '" + target + "'.");
             }
         }
     }
 };
 
 coreml.Model = class {
```

## netron/darknet.js

### js-beautify {}

```diff
@@ -33,39 +33,39 @@
                     // continue regardless of error
                 }
                 break;
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const metadata = await context.metadata('darknet-metadata.json');
         const openModel = (metadata, cfg, weights) => {
             return new darknet.Model(metadata, cfg, darknet.Weights.open(weights));
         };
         const identifier = context.identifier;
         const parts = identifier.split('.');
         parts.pop();
         const basename = parts.join('.');
-        switch (match) {
+        switch (target) {
             case 'darknet.weights': {
                 const stream = await context.request(basename + '.cfg', null);
                 const buffer = stream.read();
                 return openModel(metadata, buffer, context.stream);
             }
             case 'darknet.model': {
                 try {
                     const stream = await context.request(basename + '.weights', null);
                     return openModel(metadata, context.stream.peek(), stream);
                 } catch (error) {
                     return openModel(metadata, context.stream.peek(), null);
                 }
             }
             default: {
-                throw new darknet.Error("Unsupported Darknet format '" + match + "'.");
+                throw new darknet.Error("Unsupported Darknet format '" + target + "'.");
             }
         }
     }
 };
 
 darknet.Model = class {
```

## netron/dl4j.js

### js-beautify {}

```diff
@@ -19,17 +19,17 @@
             if (signature.length <= stream.length && stream.peek(signature.length).every((value, index) => value === signature[index])) {
                 return 'dl4j.coefficients';
             }
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const metadata = await context.metadata('dl4j-metadata.json');
-        switch (match) {
+        switch (target) {
             case 'dl4j.configuration': {
                 const obj = context.open('json');
                 try {
                     const stream = await context.request('coefficients.bin', null);
                     return new dl4j.Model(metadata, obj, stream.peek());
                 } catch (error) {
                     return new dl4j.Model(metadata, obj, null);
@@ -38,15 +38,15 @@
             case 'dl4j.coefficients': {
                 const stream = await context.request('configuration.json', null);
                 const reader = json.TextReader.open(stream);
                 const obj = reader.read();
                 return new dl4j.Model(metadata, obj, context.stream.peek());
             }
             default: {
-                throw new dl4j.Error("Unsupported Deeplearning4j format '" + match + "'.");
+                throw new dl4j.Error("Unsupported Deeplearning4j format '" + target + "'.");
             }
         }
     }
 };
 
 dl4j.Model = class {
```

## netron/dlc.js

### js-beautify {}

```diff
@@ -3,18 +3,18 @@
 
 dlc.ModelFactory = class {
 
     match(context) {
         return dlc.Container.open(context);
     }
 
-    async open(context, match) {
+    async open(context, target) {
         await context.require('./dlc-schema');
         dlc.schema = flatbuffers.get('dlc').dlc;
-        const container = match;
+        const container = target;
         let model = null;
         let params = null;
         const metadata_props = container.metadata;
         container.validate();
         try {
             model = container.model;
         } catch (error) {
```

## netron/hailo.js

### js-beautify {}

```diff
@@ -5,17 +5,17 @@
 
 hailo.ModelFactory = class {
 
     match(context) {
         return hailo.Container.open(context);
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const metadata = await context.metadata('hailo-metadata.json');
-        return new hailo.Model(metadata, match);
+        return new hailo.Model(metadata, target);
     }
 };
 
 hailo.Model = class {
 
     constructor(metadata, container) {
         const configuration = container.configuration;
```

## netron/hickle.js

### js-beautify {}

```diff
@@ -6,16 +6,16 @@
         const group = context.open('hdf5');
         if (group && group.attributes.get('CLASS') === 'hickle') {
             return group;
         }
         return null;
     }
 
-    async open(context, match) {
-        return new hickle.Model(match);
+    async open(context, target) {
+        return new hickle.Model(target);
     }
 };
 
 hickle.Model = class {
 
     constructor(group) {
         this._graphs = [new hickle.Graph(group)];
```

## netron/index.html

```diff
@@ -1,15 +1,15 @@
 <!DOCTYPE html>
 <html lang="en">
 <head>
 <meta charset="utf-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
 <meta http-equiv="Content-Security-Policy" content="script-src 'self' www.google-analytics.com;">
-<meta name="version" content="7.0.3">
-<meta name="date" content="2023-07-08 02:03:41">
+<meta name="version" content="7.0.4">
+<meta name="date" content="2023-07-15 04:18:14">
 <title>Netron</title>
 <link rel="stylesheet" type="text/css" href="grapher.css">
 <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
 <link rel="icon" type="image/png" href="icon.png">
 <link rel="apple-touch-icon" type="image/png" href="icon.png">
 <link rel="apple-touch-icon-precomposed" type="image/png" href="icon.png">
 <link rel="fluid-icon" type="image/png" href="icon.png">
@@ -170,15 +170,15 @@
 }
 @media only screen and (max-device-width: 1024px) {
 .toolbar-button { width: 32px; height: 32px; }
 .toolbar-back-button { margin-top: 6px; margin-bottom: 6px; }
 .toolbar-name-button { margin-top: 6px; margin-bottom: 6px; }
 }
 .sidebar { display: flex; flex-direction: column; font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif; font-size: 12px; height: 100%; right: -100%; position: fixed; transition: 0.1s; top: 0; background-color: #ececec; color: #242424; overflow: hidden; border-left: 1px solid rgba(255, 255, 255, 0.5); opacity: 0; }
-.sidebar-title { font-weight: bold; font-size: 12px; letter-spacing: 0.5px; height: 20px; margin: 0; padding: 20px; user-select: none; -webkit-user-select: none; -moz-user-select: none; }
+.sidebar-title { font-weight: bold; font-size: 12px; letter-spacing: 0.5px; text-transform: uppercase; height: 20px; margin: 0; padding: 20px; user-select: none; -webkit-user-select: none; -moz-user-select: none; }
 .sidebar-closebutton { padding: 8px 8px 8px 32px; text-decoration: none; font-size: 25px; color: #777777; opacity: 1.0; display: block; transition: 0.2s; position: absolute; top: 0; right: 15px; margin-left: 50px; user-select: none; -webkit-user-select: none; -moz-user-select: none; }
 .sidebar-closebutton:hover { color: #242424; }
 .sidebar-content { display: flex; flex-direction: column; flex-grow: 1; height: 0; }
 .sidebar-header { font-weight: bold; font-size: 11px; text-transform: uppercase; line-height: 1.25; margin-top: 16px; margin-bottom: 16px; border-bottom: 1px solid #ececec; display: block; user-select: none; -webkit-user-select: none; -moz-user-select: none; cursor: default; }
 .sidebar-node { flex-grow: 1; padding: 0px 20px 20px 20px; overflow-y: auto; }
 .sidebar-item { margin-bottom: 0px; display: block; }
 .sidebar-item-name { float: left; font-size: 11px; min-width: 95px; max-width: 95px; padding-right: 5px; padding-top: 7px; display: block; }
```

## netron/index.js

### js-beautify {}

```diff
@@ -87,14 +87,21 @@
             callback();
         };
         button.focus();
     } else {
         button.style.display = 'none';
         button.onclick = null;
     }
+    if (window.__view__) {
+        try {
+            window.__view__.show('welcome message');
+        } catch (error) {
+            // continue regardless of error
+        }
+    }
     document.body.setAttribute('class', 'welcome message');
 };
 
 window.addEventListener('error', (event) => {
     var error = event instanceof ErrorEvent && event.error && event.error instanceof Error ? event.error : new Error(event && event.message ? event.message : JSON.stringify(event));
     window.terminate(error.message);
 });
@@ -106,10 +113,11 @@
     window.preload(function(value, error) {
         if (error) {
             window.terminate(error.message);
         } else {
             var host = new window.host.BrowserHost();
             var view = require('./view');
             window.__view__ = new view.View(host);
+            window.__view__.start();
         }
     });
 });
```

## netron/keras.js

### js-beautify {}

```diff
@@ -28,20 +28,20 @@
             pickle.__class__.__module__ === 'keras.engine.sequential' &&
             pickle.__class__.__name__ === 'Sequential') {
             return 'keras.pickle';
         }
         return null;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const openModel = async (format, producer, backend, config, weights) => {
             const metadata = await context.metadata('keras-metadata.json');
             return new keras.Model(metadata, format, producer, backend, config, weights);
         };
-        switch (match) {
+        switch (target) {
             case 'keras.h5': {
                 const find_root_group = (root_group) => {
                     const kerasmodel = root_group.group('model/kerasmodel');
                     if (kerasmodel && kerasmodel.attributes.has('model_config')) {
                         return kerasmodel;
                     }
                     return root_group;
@@ -131,14 +131,47 @@
                                     }
                                 }
                             }
                         }
                     }
                     return openModel(format, '', backend, null, weights);
                 }
+                if (context.identifier === 'model.weights.h5' &&
+                    group.attributes.size === 0 &&
+                    group.groups.has('_layer_checkpoint_dependencies')) {
+                    const checkpoint = group.groups.get('_layer_checkpoint_dependencies');
+                    for (const layer of checkpoint.groups) {
+                        for (const vars of layer[1].groups) {
+                            for (const entry of vars[1].groups) {
+                                const variable = entry[1].value;
+                                const layout = variable.littleEndian ? '<' : '>';
+                                const tensor = new keras.Tensor(entry[0], variable.shape, variable.type, null, layout, variable.data);
+                                weights.add(layer[0], tensor);
+                            }
+                        }
+                    }
+                    let model_config = null;
+                    try {
+                        const stream = await context.request('config.json', 'utf-8');
+                        const reader = json.TextReader.open(stream);
+                        model_config = reader.read();
+                    } catch (error) {
+                        // continue regardless of error
+                    }
+                    let metadata = null;
+                    try {
+                        const stream = await context.request('metadata.json', 'utf-8');
+                        const reader = json.TextReader.open(stream);
+                        metadata = reader.read();
+                    } catch (error) {
+                        // continue regardless of error
+                    }
+                    const format = 'Keras' + (metadata && metadata.keras_version ? ' v' + metadata.keras_version : '');
+                    return openModel(format, '', '', model_config, weights);
+                }
                 const rootKeys = new Set(root_group.attributes.keys());
                 rootKeys.delete('nb_layers');
                 if (rootKeys.size > 0 || root_group.value !== null) {
                     throw new keras.Error('File format is not HDF5 Weights.');
                 }
                 const format = 'HDF5 Weights';
                 let weights_group = root_group;
@@ -247,15 +280,15 @@
                             }
                         }
                     }
                 }
                 return openModel(format, '', backend, model_config, weights);
             }
             default: {
-                throw new keras.Error("Unsupported Keras format '" + match + "'.");
+                throw new keras.Error("Unsupported Keras format '" + target + "'.");
             }
         }
     }
 };
 
 keras.Model = class {
```

## netron/kmodel.js

### js-beautify {}

```diff
@@ -3,16 +3,16 @@
 
 kmodel.ModelFactory = class {
 
     match(context) {
         return kmodel.Reader.open(context.stream);
     }
 
-    async open(context, match) {
-        return new kmodel.Model(match);
+    async open(context, target) {
+        return new kmodel.Model(target);
     }
 };
 
 kmodel.Model = class {
 
     constructor(model) {
         this._format = 'kmodel v' + model.version.toString();
```

## netron/lasagne.js

### js-beautify {}

```diff
@@ -8,17 +8,17 @@
         const obj = context.open('pkl');
         if (obj && obj.__class__ && obj.__class__.__module__ === 'nolearn.lasagne.base' && obj.__class__.__name__ == 'NeuralNet') {
             return obj;
         }
         return null;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const metadata = await context.metadata('lasagne-metadata.json');
-        return new lasagne.Model(metadata, match);
+        return new lasagne.Model(metadata, target);
     }
 };
 
 lasagne.Model = class {
 
     constructor(metadata, model) {
         this._graphs = [new lasagne.Graph(metadata, model)];
```

## netron/lightgbm.js

### js-beautify {}

```diff
@@ -12,18 +12,18 @@
         const obj = context.open('pkl');
         if (obj && obj.__class__ && obj.__class__.__module__ && obj.__class__.__module__.startsWith('lightgbm.')) {
             return 'lightgbm.pickle';
         }
         return null;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         let obj;
         let format;
-        switch (match) {
+        switch (target) {
             case 'lightgbm.pickle': {
                 obj = context.open('pkl');
                 format = 'LightGBM Pickle';
                 break;
             }
             case 'lightgbm.text': {
                 const stream = context.stream;
@@ -33,15 +33,15 @@
                 const execution = new python.Execution();
                 obj = execution.invoke('lightgbm.basic.Booster', []);
                 obj.LoadModelFromString(model_str);
                 format = 'LightGBM';
                 break;
             }
             default: {
-                throw new lightgbm.Error("Unsupported LightGBM format '" + match + "'.");
+                throw new lightgbm.Error("Unsupported LightGBM format '" + target + "'.");
             }
         }
         return new lightgbm.Model(obj, format);
     }
 };
 
 lightgbm.Model = class {
```

## netron/megengine.js

### js-beautify {}

```diff
@@ -30,20 +30,20 @@
         const obj = context.open('pkl');
         if (obj && obj.__class__ && obj.__class__.__module__ === 'megengine.traced_module.traced_module' && obj.__class__.__name__ === 'TracedModule') {
             return 'megengine.tm';
         }
         return '';
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const metadata = await context.metadata('megengine-metadata.json');
-        switch (match) {
+        switch (target) {
             case 'megengine.tm': {
                 const obj = context.open('pkl');
-                return new megengine.Model(metadata, obj, match);
+                return new megengine.Model(metadata, obj, target);
             }
             case 'megengine.mge': {
                 await context.require('./megengine-schema');
                 megengine.schema = flatbuffers.get('megengine').mgb.serialization.fbs;
                 let model = null;
                 const stream = context.stream;
                 try {
@@ -53,18 +53,18 @@
                     stream.skip(4);
                     const reader = flatbuffers.BinaryReader.open(stream);
                     model = megengine.schema.v2.Model.create(reader);
                 } catch (error) {
                     const message = error && error.message ? error.message : error.toString();
                     throw new megengine.Error('File format is not megengine.Model (' + message.replace(/\.$/, '') + ').');
                 }
-                return new megengine.Model(metadata, model, match);
+                return new megengine.Model(metadata, model, target);
             }
             default: {
-                throw new megengine.Error("Unsupported MegEngine format '" + match.replace(/^megengine\./, '') + "'.");
+                throw new megengine.Error("Unsupported MegEngine format '" + target.replace(/^megengine\./, '') + "'.");
             }
         }
     }
 };
 
 megengine.Model = class {
```

## netron/mxnet.js

### js-beautify {}

```diff
@@ -19,15 +19,15 @@
             if (stream && stream.length > signature.length && stream.peek(signature.length).every((value, index) => value == signature[index])) {
                 return 'mxnet.params';
             }
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const metadata = await context.metadata('mxnet-metadata.json');
         const basename = (base, identifier, extension, suffix, append) => {
             if (!base) {
                 if (identifier.toLowerCase().endsWith(extension)) {
                     const items = identifier.substring(0, identifier.length - extension.length).split('-');
                     if (items.length >= 2) {
                         const token = items.pop();
@@ -175,15 +175,15 @@
                 if (symbol.nodes && symbol.nodes.some((node) => node && node.op == 'tvm_op')) {
                     manifest.producer = 'TVM';
                 }
             }
             return new mxnet.Model(metadata, manifest, symbol, parameters);
         };
         const identifier = context.identifier;
-        switch (match) {
+        switch (target) {
             case 'mxnet.json': {
                 let symbol = null;
                 try {
                     symbol = context.open('json');
                 } catch (error) {
                     const message = error && error.message ? error.message : error.toString();
                     throw new mxnet.Error("Failed to load symbol entry (" + message.replace(/\.$/, '') + ').');
@@ -219,15 +219,15 @@
                     }
                     return createModel(metadata, manifest, null, params);
                 };
                 const manifest = await requestManifest();
                 return requestSymbol(manifest);
             }
             default: {
-                throw new mxnet.Error("Unsupported MXNet format '" + match + "'.");
+                throw new mxnet.Error("Unsupported MXNet format '" + target + "'.");
             }
         }
     }
 };
 
 mxnet.Model = class {
```

## netron/ncnn.js

### js-beautify {}

```diff
@@ -50,27 +50,27 @@
                     return 'ncnn.weights';
                 }
             }
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const openBinary = (param, bin) => {
             const reader = new ncnn.BinaryParamReader(param);
             return new ncnn.Model(metadata, reader, bin);
         };
         const openText = (param, bin) => {
             const reader = new ncnn.TextParamReader(param);
             return new ncnn.Model(metadata, reader, bin);
         };
         const metadata = await context.metadata('ncnn-metadata.json');
         const identifier = context.identifier.toLowerCase();
         let bin = null;
-        switch (match) {
+        switch (target) {
             case 'ncnn.model': {
                 if (identifier.endsWith('.param')) {
                     bin = context.identifier.substring(0, context.identifier.length - 6) + '.bin';
                 } else if (identifier.endsWith('.cfg.ncnn')) {
                     bin = context.identifier.substring(0, context.identifier.length - 9) + '.weights.ncnn';
                 }
                 try {
@@ -105,15 +105,15 @@
                 } catch (error) {
                     const stream = await context.request(content + '.bin', null);
                     const buffer = stream.peek();
                     return openBinary(buffer, context.stream.peek());
                 }
             }
             default: {
-                throw new ncnn.Error("Unsupported ncnn format '" + match + "'.");
+                throw new ncnn.Error("Unsupported ncnn format '" + target + "'.");
             }
         }
     }
 };
 
 ncnn.Model = class {
```

## netron/nnabla.js

### js-beautify {}

```diff
@@ -11,18 +11,18 @@
             if (tags.has('network')) {
                 return 'nnabla.pbtxt';
             }
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         await context.require('./nnabla-proto');
         nnabla.proto = protobuf.get('nnabla').nnabla;
-        switch (match) {
+        switch (target) {
             case 'nnabla.pbtxt': {
                 const stream = context.stream;
                 const reader = protobuf.TextReader.open(stream);
                 const model = nnabla.proto.NNablaProtoBuf.decodeText(reader);
                 const promises = [
                     context.request('nnp_version.txt', null),
                     context.request('parameter.protobuf', null)
@@ -39,15 +39,15 @@
                     model.parameter = params.parameter;
                     return await open(model, version);
                 } catch (error) {
                     return await open(model);
                 }
             }
             default: {
-                throw new nnabla.Error("Unsupported nnabla format '" + match + "'.");
+                throw new nnabla.Error("Unsupported nnabla format '" + target + "'.");
             }
         }
     }
 };
 
 nnabla.Model = class {
```

## netron/nnef.js

### js-beautify {}

```diff
@@ -20,26 +20,26 @@
                     return 'nnef.dat';
                 }
             }
         }
         return null;
     }
 
-    async open(context, match) {
-        switch (match) {
+    async open(context, target) {
+        switch (target) {
             case 'nnef.graph': {
                 const stream = context.stream;
                 const reader = nnef.TextReader.open(stream);
                 throw new nnef.Error("NNEF v" + reader.version + " support not implemented.");
             }
             case 'nnef.dat': {
                 throw new nnef.Error('NNEF dat format support not implemented.');
             }
             default: {
-                throw new nnef.Error("Unsupported NNEF format '" + match + "'.");
+                throw new nnef.Error("Unsupported NNEF format '" + target + "'.");
             }
         }
     }
 };
 
 nnef.TextReader = class {
```

## netron/numpy.js

### js-beautify {}

```diff
@@ -41,18 +41,18 @@
                     value: weights
                 };
             }
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         let format = '';
         const graphs = [];
-        switch (match.name) {
+        switch (target.name) {
             case 'npy': {
                 format = 'NumPy Array';
                 const execution = new python.Execution();
                 const stream = context.stream;
                 const buffer = stream.peek();
                 const bytes = execution.invoke('io.BytesIO', [buffer]);
                 const array = execution.invoke('numpy.load', [bytes]);
@@ -71,15 +71,15 @@
                 });
                 break;
             }
             case 'npz': {
                 format = 'NumPy Zip';
                 const layers = new Map();
                 const execution = new python.Execution();
-                for (const entry of match.value) {
+                for (const entry of target.value) {
                     if (!entry[0].endsWith('.npy')) {
                         throw new numpy.Error("Invalid file name '" + entry.name + "'.");
                     }
                     const name = entry[0].replace(/\.npy$/, '');
                     const parts = name.split('/');
                     const parameterName = parts.pop();
                     const groupName = parts.join('/');
@@ -115,15 +115,15 @@
                         layers.set(name, {
                             name: name,
                             parameters: []
                         });
                     }
                     return layers.get(name);
                 };
-                const weights = match.value;
+                const weights = target.value;
                 let separator = undefined;
                 if (Array.from(weights.keys()).every((key) => key.indexOf('.') !== -1)) {
                     separator = '.';
                 }
                 if (Array.from(weights.keys()).every((key) => key.indexOf('_') > key.indexOf('.'))) {
                     separator = '_';
                 }
@@ -160,26 +160,26 @@
                 format = 'NumPy NDArray';
                 const layer = {
                     type: 'numpy.ndarray',
                     parameters: [{
                         name: 'value',
                         tensor: {
                             name: '',
-                            array: match.value
+                            array: target.value
                         }
                     }]
                 };
                 graphs.push({
                     layers: [layer]
                 });
                 break;
             }
             case 'dnnlib.tflib.network': {
                 format = 'dnnlib';
-                for (const obj of match.value) {
+                for (const obj of target.value) {
                     const layers = new Map();
                     for (const entry of obj.variables) {
                         const name = entry[0];
                         const value = entry[1];
                         if (numpy.Utility.isTensor(value)) {
                             const parts = name.split('/');
                             const parameterName = parts.length > 1 ? parts.pop() : '?';
@@ -204,15 +204,15 @@
                         name: obj.name,
                         layers: Array.from(layers.values())
                     });
                 }
                 break;
             }
             default: {
-                throw new numpy.Error("Unsupported NumPy format '" + match.name + "'.");
+                throw new numpy.Error("Unsupported NumPy format '" + target.name + "'.");
             }
         }
         return new numpy.Model(format, graphs);
     }
 };
 
 numpy.Model = class {
```

## netron/om.js

### js-beautify {}

```diff
@@ -6,16 +6,16 @@
 
 om.ModelFactory = class {
 
     match(context) {
         return om.Container.open(context);
     }
 
-    async open(context, match) {
-        const container = match;
+    async open(context, target) {
+        const container = target;
         await container.open();
         const metadata = await context.metadata('om-metadata.json');
         return new om.Model(metadata, container);
     }
 };
 
 om.Model = class {
```

## netron/onednn.js

### js-beautify {}

```diff
@@ -8,17 +8,17 @@
         const obj = context.open('json');
         if (obj && obj.version && obj.engine_kind && obj.fpmath_mode && obj.graph) {
             return obj;
         }
         return null;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const metadata = await context.metadata('onednn-metadata.json');
-        return new onednn.Model(metadata, match);
+        return new onednn.Model(metadata, target);
     }
 };
 
 onednn.Model = class {
 
     constructor(metadata, symbol) {
         const version = symbol.version;
```

## netron/onnx-metadata.json

### Pretty-printed

 * *Similarity: 0.9959075013183735%*

 * *Differences: {'290': "{'inputs': {1: {'description': 'Slope tensor. The shape of slope can be smaller than "*

 * *        "first input X; if so, its shape must be unidirectional broadcastable to X'}}}",*

 * * '291': "{'inputs': {1: {'description': 'Slope tensor. The shape of slope can be smaller than "*

 * *        "first input X; if so, its shape must be unidirectional broadcastable to X'}}}",*

 * * '292': "{'inputs': {1: {'description': 'Slope tensor. The shape of slope can be smaller than "*

 * *        "first input X; if so, its shape must  […]*

```diff
@@ -6826,15 +6826,15 @@
             {
                 "description": "Additional elements added to the side with higher coordinate indices in the output. Each padding value in \"output_padding\" must be less than the corresponding stride/dilation dimension. By default, this attribute is a zero vector. Note that this attribute doesn't directly affect the computed output values. It only controls the selection of the computed values, so changing this attribute only adds or removes output elements. If \"output_shape\" is explicitly provided, \"output_padding\" does not contribute additional size to \"output_shape\" but participates in the computation of the needed padding amount. This is also called adjs or adjustment in some frameworks.",
                 "name": "output_padding",
                 "required": false,
                 "type": "int64[]"
             },
             {
-                "description": "The shape of the output can be explicitly set which will cause pads values to be auto generated. If output_shape is specified pads values are ignored. See doc for details for equations to generate pads",
+                "description": "The shape of the output can be explicitly set which will cause pads values to be auto generated. If output_shape is specified pads values are ignored. See doc for details for equations to generate pads. Note that the output_shape attribute value should not include dimensions for batch size and channels, which are automatically inferred.",
                 "name": "output_shape",
                 "required": false,
                 "type": "int64[]"
             },
             {
                 "description": "Padding for the beginning and ending along each spatial axis, it can take any value greater than or equal to 0. The value represent the number of pixels added to the beginning and end part of the corresponding axis. `pads` format should be as follow [x1_begin, x2_begin...x1_end, x2_end,...], where xi_begin the number of pixels added at the beginning of axis `i` and xi_end, the number of pixels added at the end of axis `i`. This attribute cannot be used simultaneously with auto_pad attribute. If not present, the padding defaults to 0 along start and end of each spatial axis.",
                 "name": "pads",
@@ -11731,14 +11731,70 @@
             }
         ],
         "version": 13
     },
     {
         "attributes": [
             {
+                "default": "none",
+                "description": "Gelu approximation algorithm: `\"tanh\"`, `\"none\"`(default).`\"none\"`: do not use approximation.`\"tanh\"`: use tanh approximation.",
+                "name": "approximate",
+                "required": false,
+                "type": "string"
+            }
+        ],
+        "description": "Gelu takes one input data (Tensor<T>) and produces one\noutput data (Tensor<T>) where the gaussian error linear units function,\n$y = 0.5 * x * (1 + erf(x/sqrt(2)))$ is applied to the tensor elementwise.\nIf the attribute \"approximate\" is set to \"tanh\", the function estimation,\n$y = 0.5 * x * (1 + Tanh(sqrt(2/\\pi) * (x + 0.044715 * x^3)))$ is used and applied\nto the tensor elementwise.\n\n",
+        "examples": [
+            {
+                "code": "node = onnx.helper.make_node(\"Gelu\", inputs=[\"x\"], outputs=[\"y\"])\n\nx = np.array([-1, 0, 1]).astype(np.float32)\n# expected output [-0.15865526, 0., 0.84134474]\ny = (0.5 * x * (1 + np.vectorize(math.erf)(x / np.sqrt(2)))).astype(np.float32)\nexpect(node, inputs=[x], outputs=[y], name=\"test_gelu_default_1\")\n\nx = np.random.randn(3, 4, 5).astype(np.float32)\n# expected output [2.99595031, 3.99987331, 4.99999857]\ny = (0.5 * x * (1 + np.vectorize(math.erf)(x / np.sqrt(2)))).astype(np.float32)\nexpect(node, inputs=[x], outputs=[y], name=\"test_gelu_default_2\")",
+                "summary": "gelu_default"
+            },
+            {
+                "code": "node = onnx.helper.make_node(\n    \"Gelu\", inputs=[\"x\"], outputs=[\"y\"], approximate=\"tanh\"\n)\n\nx = np.array([-1, 0, 1]).astype(np.float32)\n# expected output [-0.158808, 0., 0.841192]\ny = (\n    0.5\n    * x\n    * (1 + np.tanh(np.sqrt(2 / np.pi) * (x + 0.044715 * np.power(x, 3))))\n).astype(np.float32)\nexpect(node, inputs=[x], outputs=[y], name=\"test_gelu_tanh_1\")\n\nx = np.random.randn(3, 4, 5).astype(np.float32)\n# expected output [2.9963627, 3.99993, 4.9999995]\ny = (\n    0.5\n    * x\n    * (1 + np.tanh(np.sqrt(2 / np.pi) * (x + 0.044715 * np.power(x, 3))))\n).astype(np.float32)\nexpect(node, inputs=[x], outputs=[y], name=\"test_gelu_tanh_2\")",
+                "summary": "gelu_tanh"
+            }
+        ],
+        "inputs": [
+            {
+                "description": "Input tensor",
+                "name": "X",
+                "type": "T"
+            }
+        ],
+        "max_input": 1,
+        "max_output": 1,
+        "min_input": 1,
+        "min_output": 1,
+        "module": "ai.onnx",
+        "name": "Gelu",
+        "outputs": [
+            {
+                "description": "Output tensor",
+                "name": "Y",
+                "type": "T"
+            }
+        ],
+        "support_level": "common",
+        "type_constraints": [
+            {
+                "allowed_type_strs": [
+                    "tensor(float16)",
+                    "tensor(float)",
+                    "tensor(double)",
+                    "tensor(bfloat16)"
+                ],
+                "description": "Constrain input and output types to float tensors.",
+                "type_param_str": "T"
+            }
+        ],
+        "version": 20
+    },
+    {
+        "attributes": [
+            {
                 "default": 1.0,
                 "description": "Scalar multiplier for the product of input tensors A * B, the default value is 1.0.",
                 "name": "alpha",
                 "required": false,
                 "type": "float32"
             },
             {
@@ -23124,15 +23180,15 @@
         "inputs": [
             {
                 "description": "Input tensor",
                 "name": "X",
                 "type": "T"
             },
             {
-                "description": "Slope tensor. The shape of slope can be smaller then first input X; if so, its shape must be unidirectional broadcastable to X",
+                "description": "Slope tensor. The shape of slope can be smaller than first input X; if so, its shape must be unidirectional broadcastable to X",
                 "name": "slope",
                 "type": "T"
             }
         ],
         "max_input": 2,
         "max_output": 1,
         "min_input": 2,
@@ -23176,15 +23232,15 @@
         "inputs": [
             {
                 "description": "Input tensor",
                 "name": "X",
                 "type": "T"
             },
             {
-                "description": "Slope tensor. The shape of slope can be smaller then first input X; if so, its shape must be unidirectional broadcastable to X",
+                "description": "Slope tensor. The shape of slope can be smaller than first input X; if so, its shape must be unidirectional broadcastable to X",
                 "name": "slope",
                 "type": "T"
             }
         ],
         "max_input": 2,
         "max_output": 1,
         "min_input": 2,
@@ -23232,15 +23288,15 @@
         "inputs": [
             {
                 "description": "Input tensor",
                 "name": "X",
                 "type": "T"
             },
             {
-                "description": "Slope tensor. The shape of slope can be smaller then first input X; if so, its shape must be unidirectional broadcastable to X",
+                "description": "Slope tensor. The shape of slope can be smaller than first input X; if so, its shape must be unidirectional broadcastable to X",
                 "name": "slope",
                 "type": "T"
             }
         ],
         "max_input": 2,
         "max_output": 1,
         "min_input": 2,
@@ -36418,14 +36474,59 @@
                 "description": "Constrain input and output types to all tensor types.",
                 "type_param_str": "T"
             }
         ],
         "version": 13
     },
     {
+        "description": "StringConcat concatenates string tensors elementwise (with NumPy-style broadcasting support)",
+        "examples": [
+            {
+                "code": "node = onnx.helper.make_node(\n    \"StringConcat\",\n    inputs=[\"x\", \"y\"],\n    outputs=[\"result\"],\n)\nx = np.array([\"abc\", \"def\"]).astype(\"object\")\ny = np.array([\".com\", \".net\"]).astype(\"object\")\nresult = np.array([\"abc.com\", \"def.net\"]).astype(\"object\")\n\nexpect(node, inputs=[x, y], outputs=[result], name=\"test_string_concat\")\n\nx = np.array([\"cat\", \"dog\", \"snake\"]).astype(\"object\")\ny = np.array([\"s\"]).astype(\"object\")\nresult = np.array([\"cats\", \"dogs\", \"snakes\"]).astype(\"object\")\n\nexpect(\n    node,\n    inputs=[x, y],\n    outputs=[result],\n    name=\"test_string_concat_broadcasting\",\n)\n\nx = np.array(\"cat\").astype(\"object\")\ny = np.array(\"s\").astype(\"object\")\nresult = np.array(\"cats\").astype(\"object\")\n\nexpect(\n    node,\n    inputs=[x, y],\n    outputs=[result],\n    name=\"test_string_concat_zero_dimensional\",\n)\n\nx = np.array([\"abc\", \"\"]).astype(\"object\")\ny = np.array([\"\", \"abc\"]).astype(\"object\")\nresult = np.array([\"abc\", \"abc\"]).astype(\"object\")\n\nexpect(\n    node,\n    inputs=[x, y],\n    outputs=[result],\n    name=\"test_string_concat_empty_string\",\n)\n\nx = np.array([\"\u7684\", \"\u4e2d\"]).astype(\"object\")\ny = np.array([\"\u7684\", \"\u4e2d\"]).astype(\"object\")\nresult = np.array([\"\u7684\u7684\", \"\u4e2d\u4e2d\"]).astype(\"object\")\n\nexpect(\n    node,\n    inputs=[x, y],\n    outputs=[result],\n    name=\"test_string_concat_utf8\",\n)",
+                "summary": "stringconcat"
+            }
+        ],
+        "inputs": [
+            {
+                "description": "Tensor to prepend in concatenation",
+                "name": "X",
+                "type": "T"
+            },
+            {
+                "description": "Tensor to append in concatenation",
+                "name": "Y",
+                "type": "T"
+            }
+        ],
+        "max_input": 2,
+        "max_output": 1,
+        "min_input": 2,
+        "min_output": 1,
+        "module": "ai.onnx",
+        "name": "StringConcat",
+        "outputs": [
+            {
+                "description": "Concatenated string tensor",
+                "name": "Z",
+                "type": "T"
+            }
+        ],
+        "support_level": "common",
+        "type_constraints": [
+            {
+                "allowed_type_strs": [
+                    "tensor(string)"
+                ],
+                "description": "Inputs and outputs must be UTF-8 strings",
+                "type_param_str": "T"
+            }
+        ],
+        "version": 20
+    },
+    {
         "attributes": [
             {
                 "default": "NONE",
                 "description": "string enum that cases output to be lowercased/uppercases/unchanged. Valid values are \"LOWER\", \"UPPER\", \"NONE\". Default is \"NONE\"",
                 "name": "case_change_action",
                 "required": false,
                 "type": "string"
```

## netron/onnx.js

### js-beautify {}

```diff
@@ -226,20 +226,20 @@
             if (signature[0] === 0x80 && signature[1] < 7) {
                 return 'onnx.pickle';
             }
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const open = async (model, format) => {
             const metadata = await onnx.Metadata.open(context);
             return new onnx.Model(metadata, model, format);
         };
-        switch (match) {
+        switch (target) {
             case 'onnx.pbtxt.ModelProto':
                 await context.require('./onnx-proto');
                 try {
                     onnx.proto = protobuf.get('onnx').onnx;
                     const stream = context.stream;
                     const reader = protobuf.TextReader.open(stream);
                     const model = onnx.proto.ModelProto.decodeText(reader);
@@ -333,15 +333,15 @@
                     throw new onnx.Error('File format is not onnx.ModelProto (' + message.replace(/\.$/, '') + ').');
                 }
             }
             case 'onnx.pickle': {
                 throw new onnx.Error('Unsupported Pickle content.');
             }
             default: {
-                throw new onnx.Error("Unsupported ONNX format '" + match + "'.");
+                throw new onnx.Error("Unsupported ONNX format '" + target + "'.");
             }
         }
     }
 };
 
 onnx.Model = class {
```

## netron/openvino.js

### js-beautify {}

```diff
@@ -1,51 +1,48 @@
 var openvino = {};
 var xml = require('./xml');
 
 openvino.ModelFactory = class {
 
     match(context) {
-        const tags = context.tags('xml');
-        if (tags.has('net')) {
-            return 'openvino.xml';
-        }
         const identifier = context.identifier;
         const extension = identifier.split('.').pop().toLowerCase();
         if (extension === 'bin') {
             if (identifier === 'natives_blob.bin' || identifier === 'snapshot_blob.bin' || identifier === 'v8_context_snapshot.bin') {
                 return undefined;
             }
             const stream = context.stream;
             const signature = [0x21, 0xA8, 0xEF, 0xBE, 0xAD, 0xDE];
             if (signature.length <= stream.length && stream.peek(signature.length).every((value, index) => value === signature[index])) {
                 return undefined;
             }
             if (stream.length > 4) {
-                const buffer = stream.peek(4);
+                const buffer = stream.peek(Math.min(256, stream.length));
                 const signature = (buffer[0] | buffer[1] << 8 | buffer[2] << 16 | buffer[3] << 24) >>> 0;
                 if (signature === 0x00000000 || signature === 0x00000001 ||
                     signature === 0x01306B47 || signature === 0x000D4B38 || signature === 0x0002C056) {
                     return undefined;
                 }
-            }
-            if (stream.length > 4) {
-                const buffer = stream.peek(Math.min(256, stream.length));
                 for (let i = 0; i < buffer.length - 4; i++) {
                     const signature = (buffer[i] | buffer[i + 1] << 8 | buffer[i + 2] << 16 | buffer[i + 3] << 24) >>> 0;
                     if (signature === 0xdeadbeef) {
                         return undefined;
                     }
                 }
             }
             return 'openvino.bin';
         }
+        const tags = context.tags('xml');
+        if (tags.has('net')) {
+            return 'openvino.xml';
+        }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const open = async (stream, bin) => {
             const metadata = await context.metadata('openvino-metadata.json');
             let document = null;
             try {
                 const reader = xml.TextReader.open(stream);
                 document = reader.read();
             } catch (error) {
@@ -55,29 +52,29 @@
             if (!document.documentElement || document.documentElement.localName != 'net') {
                 throw new openvino.Error('File format is not OpenVINO IR.');
             }
             const net = openvino.XmlReader.read(document.documentElement);
             return new openvino.Model(metadata, net, bin);
         };
         const identifier = context.identifier;
-        switch (match) {
+        switch (target) {
             case 'openvino.xml':
                 try {
                     const stream = await context.request(identifier.substring(0, identifier.length - 4) + '.bin', null);
                     const buffer = stream.read();
                     return open(context.stream, buffer);
                 } catch (error) {
                     return open(context.stream, null);
                 }
             case 'openvino.bin': {
                 const stream = await context.request(identifier.substring(0, identifier.length - 4) + '.xml', null);
                 return open(stream, context.stream.peek());
             }
             default:
-                throw new openvino.Error("Unsupported OpenVINO format '" + match + "'.");
+                throw new openvino.Error("Unsupported OpenVINO format '" + target + "'.");
         }
     }
 };
 
 openvino.Model = class {
 
     constructor(metadata, net, bin) {
```

## netron/paddle.js

### js-beautify {}

```diff
@@ -33,33 +33,33 @@
         }
         if (paddle.NaiveBuffer.open(context)) {
             return 'paddle.naive';
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const metadata = await context.metadata('paddle-metadata.json');
-        switch (match) {
+        switch (target) {
             case 'paddle.naive': {
                 await context.require('./paddle-schema');
                 paddle.schema = flatbuffers.get('paddlelite').paddle.lite.fbs.proto;
                 const file = paddle.NaiveBuffer.open(context);
                 return new paddle.Model(metadata, file.format, file.model, file.weights);
             }
             default: {
                 await context.require('./paddle-proto');
                 paddle.proto = protobuf.get('paddle').paddle.framework.proto;
                 const identifier = context.identifier;
                 const parts = identifier.split('.');
                 const extension = parts.pop().toLowerCase();
                 const base = parts.join('.');
-                const openProgram = (stream, match) => {
+                const openProgram = (stream, target) => {
                     const program = {};
-                    switch (match) {
+                    switch (target) {
                         case 'paddle.pbtxt': {
                             try {
                                 const reader = protobuf.TextReader.open(stream);
                                 program.desc = paddle.proto.ProgramDesc.decodeText(reader);
                             } catch (error) {
                                 const message = error && error.message ? error.message : error.toString();
                                 throw new paddle.Error('File text format is not paddle.ProgramDesc (' + message.replace(/\.$/, '') + ').');
@@ -73,15 +73,15 @@
                             } catch (error) {
                                 const message = error && error.message ? error.message : error.toString();
                                 throw new paddle.Error('File format is not paddle.ProgramDesc (' + message.replace(/\.$/, '') + ').');
                             }
                             break;
                         }
                         default: {
-                            throw new paddle.Error("Unsupported Paddle format '" + match + "'.");
+                            throw new paddle.Error("Unsupported Paddle format '" + target + "'.");
                         }
                     }
                     const formatVersion = (version) => {
                         if (version && version.version && version.version.toNumber) {
                             const number = version.version.toNumber();
                             if (number > 0) {
                                 const list = [Math.floor(number / 1000000) % 1000, Math.floor(number / 1000) % 1000, number % 1000];
@@ -135,15 +135,15 @@
                     const weights = new Map();
                     const vars = program.vars.slice();
                     for (const param of params) {
                         weights.set(vars.shift(), param);
                     }
                     return weights;
                 };
-                switch (match) {
+                switch (target) {
                     case 'paddle.pickle': {
                         const container = paddle.Pickle.open(context);
                         return createModel(metadata, container.format, null, container.weights);
                     }
                     case 'paddle.entries': {
                         const container = paddle.Entries.open(context);
                         return createModel(metadata, container.format, null, container.weights);
@@ -173,15 +173,15 @@
                         const openNumPyArrayPickle = (stream) => {
                             const execution = new python.Execution();
                             const unpickler = execution.invoke('pickle.Unpickler', [stream]);
                             const obj = unpickler.load();
                             const container = new paddle.Pickle(obj);
                             return container.weights || new Map();
                         };
-                        const program = openProgram(context.stream, match);
+                        const program = openProgram(context.stream, target);
                         if (extension === 'pdmodel') {
                             try {
                                 const stream = await context.request(base + '.pdiparams', null);
                                 const params = loadParams(stream);
                                 const weights = mapParams(params, program);
                                 return createModel(metadata, program.format, program.desc, weights);
                             } catch (error) {
@@ -219,15 +219,15 @@
                             } catch (error) {
                                 return loadEntries(context, program);
                             }
                         }
                         return loadEntries(context, program);
                     }
                     default: {
-                        throw new paddle.Error("Unsupported PaddlePaddle format '" + match + "'.");
+                        throw new paddle.Error("Unsupported PaddlePaddle format '" + target + "'.");
                     }
                 }
             }
         }
     }
 };
```

## netron/pickle.js

### js-beautify {}

```diff
@@ -17,17 +17,17 @@
             if (!name.startsWith('__torch__.')) {
                 return obj;
             }
         }
         return null;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         let format = 'Pickle';
-        const obj = match;
+        const obj = target;
         if (obj === null || obj === undefined) {
             context.exception(new pickle.Error("Unsupported Pickle null object in '" + context.identifier + "'."));
         } else if (Array.isArray(obj)) {
             if (obj.length > 0 && obj[0] && obj.every((item) => item && item.__class__ && obj[0].__class__ && item.__class__.__module__ === obj[0].__class__.__module__ && item.__class__.__name__ === obj[0].__class__.__name__)) {
                 const type = obj[0].__class__.__module__ + "." + obj[0].__class__.__name__;
                 context.exception(new pickle.Error("Unsupported Pickle '" + type + "' array object in '" + context.identifier + "'."));
             } else if (obj.length > 0) {
```

## netron/python.js

### js-beautify {}

```diff
@@ -1738,15 +1738,15 @@
         this.register('argparse');
         this.register('collections');
         this.register('copy_reg');
         this.register('cuml');
         this.register('gensim');
         this.register('io');
         this.register('joblib');
-        this.register('keras');
+        const keras = this.register('keras');
         this.register('lightgbm');
         this.register('nolearn');
         const math = this.register('math');
         math.inf = Infinity;
         const numpy = this.register('numpy');
         const pickle = this.register('pickle');
         this.register('sklearn');
@@ -3604,14 +3604,18 @@
                 }
                 throw err;
             }
         });
         this.registerFunction('dill._dill._load_type', function(name) {
             return self.resolve('types.' + name);
         });
+        this.registerFunction('keras.saving.pickle_utils.deserialize_model_from_bytecode', function( /* serialized_model */ ) {
+            throw new python.Error("'keras.saving.pickle_utils.deserialize_model_from_bytecode' not implemented.");
+        });
+        this.registerFunction('keras.src.saving.pickle_utils.deserialize_model_from_bytecode', keras.saving.pickle_utils.deserialize_model_from_bytecode);
         this.registerFunction('lasagne.nonlinearities.rectify', function() {
             throw new python.Error('Function not implemented.');
         });
         this.registerFunction('lasagne.nonlinearities.softmax', function() {
             throw new python.Error('Function not implemented.');
         });
         this.registerFunction('lasagne.objectives.categorical_crossentropy', function() {
```

## netron/pytorch.js

### js-beautify {}

```diff
@@ -7,34 +7,34 @@
 
 pytorch.ModelFactory = class {
 
     match(context) {
         return pytorch.Container.open(context);
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const metadata = await pytorch.Metadata.open(context);
-        const container = match;
-        container.metadata = metadata;
+        const container = target;
         container.on('resolve', (_, name) => {
             context.exception(new pytorch.Error("Unknown type name '" + name + "'."), false);
         });
-        await container.read();
+        await container.read(metadata);
         return new pytorch.Model(metadata, container);
     }
 };
 
 pytorch.Model = class {
 
     constructor(metadata, container) {
         this._format = container.format;
         this._producer = container.producer || '';
         this._graphs = [];
         for (const entry of container.modules) {
-            this._graphs.push(new pytorch.Graph(metadata, entry[0], entry[1], container));
+            const graph = new pytorch.Graph(metadata, entry[0], entry[1]);
+            this._graphs.push(graph);
         }
     }
 
     get format() {
         return this._format;
     }
 
@@ -814,24 +814,19 @@
         if (mobile) {
             return mobile;
         }
         return null;
     }
 
     constructor() {
-        this._metadata = null;
         this._events = [];
     }
 
     async read() {}
 
-    set metadata(value) {
-        this._metadata = value;
-    }
-
     on(event, callback) {
         this._events.push([event, callback]);
     }
 
     get format() {
         throw new pytorch.Error('Container format not implemented.');
     }
@@ -993,18 +988,18 @@
     }
 
     constructor(context) {
         super();
         this._context = context;
     }
 
-    async read() {
+    async read(metadata) {
         await this._context.require('./pytorch-schema');
         this._modules = new Map();
-        const execution = new pytorch.jit.Execution(null, this._metadata);
+        const execution = new pytorch.jit.Execution(null, metadata);
         for (const event in this._events) {
             execution.on(event[0], event[1]);
         }
         const stream = this._context.stream;
         const torch = execution.__import__('torch');
         const module = torch.jit.jit_module_from_flatbuffer(stream);
         this._version = pytorch.Utility.version(module._c._bytecode_version);
@@ -1072,16 +1067,16 @@
         } else {
             const name = this._torchscript ? 'TorchScript' : 'PyTorch';
             const version = pytorch.Utility.version(reader.version());
             this._format = name + ' ' + version;
         }
     }
 
-    async read() {
-        const execution = new pytorch.jit.Execution(null, this._metadata);
+    async read(metadata) {
+        const execution = new pytorch.jit.Execution(null, metadata);
         for (const event in this._events) {
             execution.on(event[0], event[1]);
         }
         const torch = execution.__import__('torch');
         if (this._torchscript) {
             const module = torch.jit.load(this._reader);
             if (module.data && module.data.forward) {
@@ -2741,20 +2736,21 @@
                 statement.target.type === 'id' &&
                 pytorch.Utility.isCall(statement.expression, 'torch.len', 1)) {
                 const tensor = this.expression(statement.expression.args[0], context);
                 if (pytorch.Utility.isTensor(tensor) && tensor.__origin__ === 'graph-input' && tensor.shape === undefined) {
                     tensor.resize_([NaN, NaN, NaN, NaN]);
                 }
             }
+            // x = _(torch.size(foo ,2))
             if (statement.type === '=' &&
                 statement.expression.type === 'call' && statement.expression.args.length > 0 &&
                 pytorch.Utility.isCall(statement.expression.args[0], 'torch.size', 2)) {
                 const tensor = this.expression(statement.expression.args[0].args[0], context);
                 const dim = this.expression(statement.expression.args[0].args[1], context);
-                if (pytorch.Utility.isTensor(tensor) && Number.isInteger(dim)) {
+                if (pytorch.Utility.isTensor(tensor) && Number.isInteger(dim) && dim >= 0) {
                     if (tensor.shape === undefined) {
                         tensor.resize_(Array(dim + 1).fill(NaN));
                     } else if (Array.isArray(tensor.shape) && tensor.shape.length <= dim) {
                         tensor.resize_(tensor.shape.concat(Array(dim + 1 - tensor.shape.length).fill(NaN)));
                     }
                 }
             }
@@ -3454,17 +3450,17 @@
                         const data = obj.get('engine');
                         const signatures = [
                             [0x70, 0x74, 0x72, 0x74], // ptrt
                             [0x66, 0x74, 0x72, 0x74] // ftrt
                         ];
                         for (const signature of signatures) {
                             if (data instanceof Uint8Array && data.length > signature.length && signature.every((value, index) => value === data[index])) {
-                                const buffer = data.slice(0, 24);
-                                const content = Array.from(buffer).map((c) => (c < 16 ? '0' : '') + c.toString(16)).join('');
-                                throw new pytorch.Error("Invalid file content. File contains undocumented PyTorch TensorRT engine data (" + content.substring(8) + ").");
+                                // const buffer = data.slice(0, 24);
+                                // const content = Array.from(buffer).map((c) => (c < 16 ? '0' : '') + c.toString(16)).join('');
+                                throw new pytorch.Error('Invalid file content. File contains undocumented PyTorch TensorRT engine data.');
                             }
                         }
                     }
                     if (obj._modules) {
                         return new Map([
                             ['', obj]
                         ]);
```

## netron/rknn.js

### js-beautify {}

```diff
@@ -5,19 +5,19 @@
 
 rknn.ModelFactory = class {
 
     match(context) {
         return rknn.Container.open(context);
     }
 
-    async open(context, match) {
+    async open(context, target) {
         await context.require('./rknn-schema');
         rknn.schema = flatbuffers.get('rknn').rknn;
         const metadata = await context.metadata('rknn-metadata.json');
-        const container = match;
+        const container = target;
         const type = container.type;
         switch (type) {
             case 'json': {
                 const buffer = container.value;
                 const reader = json.TextReader.open(buffer);
                 const model = reader.read();
                 return new rknn.Model(metadata, type, model, container.next);
```

## netron/safetensors.js

### js-beautify {}

```diff
@@ -15,18 +15,18 @@
                     };
                 }
             }
         }
         return '';
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const stream = context.stream;
         stream.seek(8);
-        const buffer = stream.read(match.size);
+        const buffer = stream.read(target.size);
         const reader = json.TextReader.open(buffer);
         const obj = reader.read();
         const model = new safetensors.Model(obj, stream.position, stream);
         stream.seek(0);
         return model;
     }
 };
```

## netron/server.js

### js-beautify {}

```diff
@@ -16,16 +16,16 @@
                     return obj;
                 }
             }
         }
         return null;
     }
 
-    async open(context, match) {
-        return new message.Model(match);
+    async open(context, target) {
+        return new message.Model(target);
     }
 };
 
 message.Model = class {
 
     constructor(data) {
         this._format = data.format || '';
```

## netron/server.py

```diff
@@ -11,15 +11,15 @@
 import socketserver
 import sys
 import threading
 import time
 import webbrowser
 import urllib.parse
 
-__version__ = '7.0.3'
+__version__ = '7.0.4'
 
 class _ContentProvider: # pylint: disable=too-few-public-methods
     data = bytearray()
     base_dir = ''
     base = ''
     identifier = ''
     def __init__(self, data, path, file):
```

## netron/sklearn.js

### js-beautify {}

```diff
@@ -42,33 +42,33 @@
                     return format.format + '.map';
                 }
             }
         }
         return null;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const metadata = await context.metadata('sklearn-metadata.json');
         const obj = context.open('pkl');
-        return new sklearn.Model(metadata, match, obj);
+        return new sklearn.Model(metadata, target, obj);
     }
 };
 
 sklearn.Model = class {
 
-    constructor(metadata, match, obj) {
+    constructor(metadata, target, obj) {
         const formats = new Map([
             ['sklearn', 'scikit-learn'],
             ['scipy', 'SciPy'],
             ['hmmlearn', 'hmmlearn']
         ]);
-        this._format = formats.get(match.split('.').shift());
+        this._format = formats.get(target.split('.').shift());
         this._graphs = [];
         const version = [];
-        switch (match) {
+        switch (target) {
             case 'sklearn':
             case 'scipy':
             case 'hmmlearn': {
                 if (obj._sklearn_version) {
                     version.push(' v' + obj._sklearn_version.toString());
                 }
                 this._graphs.push(new sklearn.Graph(metadata, '', obj));
@@ -94,15 +94,15 @@
                     if (obj._sklearn_version) {
                         version.push(' v' + obj._sklearn_version.toString());
                     }
                 }
                 break;
             }
             default: {
-                throw new sklearn.Error("Unsupported scikit-learn format '" + match + "'.");
+                throw new sklearn.Error("Unsupported scikit-learn format '" + target + "'.");
             }
         }
         if (version.length > 0 && version.every((value) => value === version[0])) {
             this._format += version[0];
         }
     }
```

## netron/tengine.js

### js-beautify {}

```diff
@@ -5,17 +5,17 @@
 
 tengine.ModelFactory = class {
 
     match(context) {
         return tengine.Reader.open(context.stream);
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const metadata = await tengine.Metadata.open(context);
-        return new tengine.Model(metadata, match);
+        return new tengine.Model(metadata, target);
     }
 };
 
 tengine.Model = class {
 
     constructor(metadata, reader) {
         this._version = reader.version;
```

## netron/tensorrt.js

### js-beautify {}

```diff
@@ -4,16 +4,16 @@
 tensorrt.ModelFactory = class {
 
     match(context) {
         const stream = context.stream;
         return tensorrt.Engine.open(stream) || tensorrt.Container.open(stream);
     }
 
-    async open(context, match) {
-        return new tensorrt.Model(null, match);
+    async open(context, target) {
+        return new tensorrt.Model(null, target);
     }
 };
 
 tensorrt.Model = class {
 
     constructor(metadata, model) {
         this._format = model.format;
@@ -103,18 +103,18 @@
                     break;
                 }
                 default: {
                     const content = Array.from(buffer).map((c) => (c < 16 ? '0' : '') + c.toString(16)).join('');
                     throw new tensorrt.Error("Unsupported TensorRT engine signature (" + content.substring(8) + ").");
                 }
             }
-            const content = Array.from(buffer).map((c) => (c < 16 ? '0' : '') + c.toString(16)).join('');
+            // const content = Array.from(buffer).map((c) => (c < 16 ? '0' : '') + c.toString(16)).join('');
             // buffer = this._stream.read(24 + size);
             // reader = new tensorrt.BinaryReader(buffer);
-            throw new tensorrt.Error("Invalid file content. File contains undocumented TensorRT engine data (" + content.substring(8) + ").");
+            throw new tensorrt.Error('Invalid file content. File contains undocumented TensorRT engine data.');
         }
     }
 };
 
 tensorrt.Container = class {
 
     static open(stream) {
```

## netron/tf.js

### js-beautify {}

```diff
@@ -274,15 +274,15 @@
                     return 'tf.pb.mmap';
                 }
             }
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         await context.require('./tf-proto');
         tf.proto = protobuf.get('tf');
         const openModel = async (saved_model, format, producer, bundle) => {
             const metadata = await context.metadata('tf-metadata.json');
             return new tf.Model(metadata, saved_model, format, producer, bundle);
         };
         const openSavedModel = async (saved_model, format, producer) => {
@@ -714,15 +714,15 @@
             const format = 'TensorFlow GraphDef Memmapped';
             const meta_graph = new tf.proto.tensorflow.MetaGraphDef();
             meta_graph.graph_def = graph_def;
             const saved_model = new tf.proto.tensorflow.SavedModel();
             saved_model.meta_graphs.push(meta_graph);
             return openSavedModel(saved_model, format, null);
         };
-        switch (match) {
+        switch (target) {
             case 'tf.bundle':
                 return openBundle(context);
             case 'tf.data':
                 return openData(context);
             case 'tf.events':
                 return openEventFile(context);
             case 'tf.json':
@@ -744,15 +744,15 @@
             case 'tf.pb.keras.SavedMetadata':
                 return openSavedMetadata(context);
             case 'tf.pb.FingerprintDef':
                 return openFingerprint(context);
             case 'tf.pb.mmap':
                 return openMemmapped(context);
             default:
-                throw new tf.Error("Unsupported TensorFlow format '" + match + "'.");
+                throw new tf.Error("Unsupported TensorFlow format '" + target + "'.");
         }
     }
 };
 
 tf.Model = class {
 
     constructor(metadata, model, format, producer, bundle) {
@@ -807,15 +807,16 @@
                 this._version = meta_graph.meta_info_def.tensorflow_version;
             }
             if (meta_graph.meta_info_def && meta_graph.meta_info_def.tags) {
                 this._tags = meta_graph.meta_info_def.tags.join(', ');
             }
             metadata = new tf.GraphMetadata(metadata, graph.library);
             const nodes = graph.node || [];
-            const context = tf.Utility.createGraph(metadata, nodes);
+            const context = new tf.Context();
+            context.graph(metadata, nodes);
             this._nodes = context.nodes;
             this._inputs = context.inputs;
             this._outputs = context.outputs;
         } else if (bundle) {
             const nodes = new Map();
             for (const tensor of bundle.tensors) {
                 const parts = tensor.name.split('/');
@@ -844,15 +845,15 @@
             }
             const namespaces = new Set();
             this._nodes = Array.from(nodes).map((entry) => {
                 const node = {
                     op: 'Node',
                     name: entry[0]
                 };
-                return new tf.Node(metadata, node, namespaces, null, entry[1]);
+                return new tf.Node(metadata, node, namespaces, new tf.Context(), entry[1]);
             });
         }
     }
 
     get name() {
         return this._name;
     }
@@ -936,43 +937,42 @@
         this._name = name;
         this._version = null;
         this._tags = null;
         this._inputs = [];
         this._outputs = [];
         this._nodes = [];
         this._description = !func ? 'Function definition not found.' : null;
-
+        const context = new tf.Context();
         const input_arg = func && func.signature ? func.signature.input_arg : [];
         const output_arg = func && func.signature ? func.signature.output_arg : [];
         const ret = func && func.ret ? func.ret : {};
         const nodes = func && func.node_def ? func.node_def : [];
-
         if (input_arg) {
             for (const input of input_arg) {
-                const value = new tf.Value(input.name, new tf.TensorType(input.type, null), null);
+                const value = context.value(input.name, new tf.TensorType(input.type, null), null);
                 this._inputs.push(new tf.Argument(input.name, [value]));
             }
         }
         const output_arg_map = new Map();
         if (output_arg) {
             const ret_map = new Map();
             for (const key of Object.keys(ret)) {
                 const value = func.ret[key];
                 const split = value.split(':', 2);
                 ret_map.set(key, split[0]);
             }
             for (const output of output_arg) {
                 const name = ret_map.get(output.name);
-                this._outputs.push(new tf.Argument(output.name, [
-                    new tf.Value(name, new tf.TensorType(output.type, null), null)
-                ]));
+                const type = new tf.TensorType(output.type, null);
+                const argument = new tf.Argument(output.name, [context.value(name, type, null)]);
+                this._outputs.push(argument);
                 output_arg_map.set(name, output.name);
             }
         }
-        const context = tf.Utility.createGraph(metadata, nodes, output_arg_map);
+        context.graph(metadata, nodes, output_arg_map);
         this._nodes = context.nodes;
         this._inputs = this._inputs.concat(context.inputs);
         this._outputs = this._outputs.concat(context.outputs);
     }
 
     get type() {
         return 'function';
@@ -1010,110 +1010,109 @@
     get nodes() {
         return this._nodes;
     }
 };
 
 tf.Node = class {
 
-    constructor(metadata, node, namespaces, initializers, tensors) {
+    constructor(metadata, node, namespaces, context, tensors) {
         this._type = node.metadata || metadata.type(node.op) || {
             name: node.op
         };
         this._name = node.name;
         this._attributes = [];
         this._inputs = [];
         this._outputs = [];
         this._group = '';
         if (node.name) {
             if (namespaces.has(node.name)) {
                 this._group = node.name;
             } else {
-                const lastIndex = node.name.lastIndexOf('/');
-                if (lastIndex != -1) {
-                    const namespace = node.name.substring(0, lastIndex);
+                const index = node.name.lastIndexOf('/');
+                if (index != -1) {
+                    const namespace = node.name.substring(0, index);
                     if (namespaces.has(namespace)) {
                         this._group = namespace;
                     }
                 }
             }
         }
         if (tensors) {
             for (const tensor of tensors) {
-                this._inputs.push(new tf.Argument(tensor.name, [
-                    new tf.Value(tensor.value.name, null, tensor.value)
-                ]));
+                const value = context.value(tensor.value.name, null, tensor.value);
+                const argument = new tf.Argument(tensor.name, [value]);
+                this._inputs.push(argument);
             }
         } else {
             if (node.device !== undefined) {
                 this._device = node.device;
             }
             if (node.attr) {
                 this._attributes = Object.entries(node.attr).map((entry) => {
                     return new tf.Attribute(metadata, node.op, entry[0], entry[1]);
                 });
             }
             let inputIndex = 0;
             const inputs = (node.input || []).filter((input) => !input.name.startsWith('^'));
             if (this._type && this._type.inputs) {
                 for (const input of this._type.inputs) {
-                    let inputCount = 1;
+                    let count = 1;
                     if (input.numberAttr) {
                         const inputNumber = node.attr[input.numberAttr];
                         if (inputNumber && inputNumber.i) {
-                            inputCount = inputNumber.i;
+                            count = inputNumber.i;
                         }
                     } else if (input.typeListAttr) {
                         const inputTypeListAttr = node.attr[input.typeListAttr];
                         if (inputTypeListAttr && inputTypeListAttr.list && inputTypeListAttr.list.type) {
-                            inputCount = inputTypeListAttr.list.type.length;
+                            count = inputTypeListAttr.list.type.length;
                         }
                     }
-                    const inputArguments = inputs.slice(inputIndex, inputIndex + inputCount).map((input) => {
-                        return initializers.has(input.name) ? initializers.get(input.name) : new tf.Value(input.name, null, null);
-                    });
-                    this._inputs.push(new tf.Argument(input.name, inputArguments));
-                    inputIndex += inputCount;
+                    const values = inputs.slice(inputIndex, inputIndex + count).map((input) => context.value(input.name, null, null));
+                    const argument = new tf.Argument(input.name, values);
+                    this._inputs.push(argument);
+                    inputIndex += count;
                 }
             }
             this._inputs.push(...inputs.slice(inputIndex).map((input, index) => {
-                return new tf.Argument(input.label ? input.label : (inputIndex + index).toString(), [
-                    initializers.has(input.name) ? initializers.get(input.name) : new tf.Value(input.name, null, null)
-                ]);
+                const name = input.label ? input.label : (inputIndex + index).toString();
+                return new tf.Argument(name, [context.value(input.name)]);
             }));
             let outputIndex = 0;
             const outputs = node.output || [];
             if (this._type && this._type.outputs) {
                 for (const output of this._type.outputs) {
-                    let outputCount = 1;
+                    let count = 1;
                     if (output.numberAttr) {
                         const outputNumber = node.attr[output.numberAttr];
                         if (outputNumber && outputNumber.i) {
-                            outputCount = outputNumber.i;
+                            count = outputNumber.i;
                         }
                     } else if (output.typeListAttr) {
                         const outputTypeListAttr = node.attr[output.typeListAttr];
                         if (outputTypeListAttr && outputTypeListAttr.list && outputTypeListAttr.list.type) {
-                            outputCount = outputTypeListAttr.list.type.length;
+                            count = outputTypeListAttr.list.type.length;
                         }
                     }
-                    const outputArguments = outputs.slice(outputIndex, outputIndex + outputCount).map((output) => {
-                        return new tf.Value(output.name ? output.name : '-', null, null);
+                    const values = outputs.slice(outputIndex, outputIndex + count).map((output) => {
+                        return context.value(output.name ? output.name : '-', null, null);
                     });
                     const name = output.name ? output.name : 'output' + (this._outputs.length == 0 ? '' : this._outputs.length.toString());
-                    this._outputs.push(new tf.Argument(name, outputArguments));
-                    outputIndex += outputCount;
+                    const argument = new tf.Argument(name, values);
+                    this._outputs.push(argument);
+                    outputIndex += count;
                 }
             }
             this._outputs.push(...outputs.slice(outputIndex).map((output, index) => {
-                return new tf.Argument((outputIndex + index).toString(), [
-                    new tf.Value(output.name ? output.name : '-', null, null)
-                ]);
+                const name = (outputIndex + index).toString();
+                const value = context.value(output.name ? output.name : '-', null, null);
+                return new tf.Argument(name, [value]);
             }));
             const controlDependencies = node.controlDependencies || [];
-            this._controlDependencies = controlDependencies.map((input) => new tf.Value(input.name));
+            this._controlDependencies = controlDependencies.map((input) => context.value(input.name));
         }
     }
 
     get type() {
         return this._type;
     }
 
@@ -1192,15 +1191,15 @@
                 break;
             }
             case 'func': {
                 this._type = 'function';
                 this._value = new tf.Node(metadata, {
                     op: value.func.name,
                     attr: value.func.attr
-                });
+                }, null, new tf.Context());
                 break;
             }
             case 'placeholder': {
                 this._type = 'placeholder';
                 this._value = value;
                 break;
             }
@@ -1451,55 +1450,58 @@
         return this._dtype ? tf.Utility.dataType(this._dtype) : '?';
     }
 
     get shape() {
         return this._shape;
     }
 
+    equals(obj) {
+        return obj && this.dataType === obj.dataType && this.shape.equals(obj.shape);
+    }
+
     toString() {
         return this.dataType + this._shape.toString();
     }
 };
 
 tf.TensorShape = class {
 
     constructor(shape) {
-        this._shape = shape;
+        this._dimensions = null;
+        if (shape) {
+            if (shape.unknown_rank) {
+                this._dimensions = null;
+            } else if (Array.isArray(shape.dim)) {
+                if (shape.dim.length == 0) {
+                    this._dimensions = [];
+                } else if (shape.dim.length == 1 && !shape.dim[0].size) {
+                    this._dimensions = [0];
+                } else {
+                    this._dimensions = shape.dim.map((dim) => (dim.size && dim.size != -1) ? dim.size : '?');
+                }
+            }
+        }
     }
 
     get dimensions() {
-        if (this._shape && this._shape.dim) {
-            if (this._shape.unknown_rank) {
-                return null;
-            }
-            if (this._shape.dim.length == 0) {
-                return [];
-            }
-            if (this._shape.dim.length == 1 && !this._shape.dim[0].size) {
-                return [0];
-            }
-            return this._shape.dim.map((dim) => (dim.size && dim.size != -1) ? dim.size : '?');
-        }
-        return null;
+        return this._unknownRank ? null : this._dimensions;
+    }
+
+    equals(obj) {
+        return (this.dimensions === null && obj.dimensions === null) || (Array.isArray(this.dimensions) && Array.isArray(obj.dimensions) && this.dimensions.length === obj.dimensions.length && this.dimensions.every((value, index) => obj.dimensions[index] === value));
     }
 
     toString() {
-        if (this._shape && this._shape.dim) {
-            if (this._shape.unknown_rank) {
-                return '[-]';
-            }
-            if (this._shape.dim.length == 0) {
-                return '';
-            }
-            if (this._shape.dim.length == 1 && !this._shape.dim[0].size) {
-                return '[0]';
-            }
-            return '[' + this._shape.dim.map((dim) => (dim.size && dim.size != -1) ? dim.size.toString() : '?').join(',') + ']';
+        if (this._dimensions === null) {
+            return '[?]';
+        }
+        if (this._dimensions.length === 0) {
+            return '';
         }
-        return '?';
+        return '[' + this._dimensions.map((dim) => (dim.size && dim.size != -1) ? dim.size.toString() : '?').join(',') + ']';
     }
 };
 
 tf.TensorBundle = class {
 
     static async open(stream, identifier, context) {
         const format = !identifier.toLowerCase().endsWith('.index') ? 1 : 2;
@@ -1982,56 +1984,36 @@
             }
             this._visibleCache.set(type, set);
         }
         return !this._visibleCache.get(type).has(name);
     }
 };
 
-tf.Utility = class {
+tf.Context = class {
 
-    static decodeText(value) {
-        if (typeof value === 'string') {
-            return value;
-        }
-        if (value.length === 0) {
-            return '';
-        }
-        tf.Utility._utf8Decoder = tf.Utility._utf8Decoder || new TextDecoder('utf-8');
-        return tf.Utility._utf8Decoder.decode(value);
+    constructor() {
+        this._values = new Map();
+        this.inputs = [];
+        this.outputs = [];
+        this.nodes = [];
     }
 
-    static dataType(type) {
-        if (!tf.Utility._dataTypes) {
-            const DataType = tf.proto.tensorflow.DataType;
-            const dataTypes = new Map(Object.entries(DataType).map((entry) => {
-                const key = entry[0].startsWith('DT_') ? entry[0].substring(3) : entry[0];
-                return [entry[1], key.toLowerCase()];
-            }));
-            dataTypes.set(DataType.DT_HALF, 'float16');
-            dataTypes.set(DataType.DT_FLOAT, 'float32');
-            dataTypes.set(DataType.DT_DOUBLE, 'float64');
-            dataTypes.set(DataType.DT_BOOL, 'boolean');
-            tf.Utility._dataTypes = dataTypes;
+    value(name, type, tensor) {
+        if (name.length === 0 && tensor) {
+            return new tf.Value(name, type || null, tensor);
         }
-        return tf.Utility._dataTypes.has(type) ? tf.Utility._dataTypes.get(type) : '?';
-    }
-
-    static dataTypeKey(type) {
-        if (!tf.Utility._dataTypeKeys) {
-            tf.Utility.dataType(0);
-            tf.Utility._dataTypeKeys = new Map(Array.from(tf.Utility._dataTypes).map((entry) => [entry[1], entry[0]]));
+        if (!this._values.has(name)) {
+            this._values.set(name, new tf.Value(name, type || null, tensor || null));
+        } else if ((type && !type.equals(this._values.get(name).type)) || tensor) {
+            throw new tf.Error("Duplicate value '" + name + "'.");
         }
-        return tf.Utility._dataTypeKeys.get(type);
+        return this._values.get(name);
     }
 
-    static createGraph(metadata, nodes, output_arg_map) {
-        const context = {};
-        context.inputs = [];
-        context.outputs = [];
-        context.nodes = [];
+    graph(metadata, nodes, output_arg_map) {
         const namespaces = new Set();
         const node_map = new Map();
         for (const node of nodes) {
             const nodeName = node.name;
             node_map.set(nodeName, node);
             if (node.op != 'Const') {
                 const index = nodeName.lastIndexOf('/');
@@ -2081,88 +2063,83 @@
                     node.output.push({
                         name: node.name,
                         to: []
                     });
                 }
             }
         }
-        const initializers = new Map();
         const map_tensor = (name, node, kind) => {
             if (node && node.op === 'Const' && node.input.length === 0 && node.output.length === 1 && node.output[0].to.length === 1 && node.controlDependencies.length === 0) {
                 const value = node.attr.value;
                 if (value && Object.prototype.hasOwnProperty.call(value, 'tensor')) {
                     const tensor = new tf.Tensor(value.tensor, name, kind);
-                    return new tf.Value(name, tensor.type, tensor);
+                    return this.value(name, tensor.type, tensor);
                 }
             }
             return null;
         };
         const map_resource = (name, node, tensor) => {
             if (node && node.op === 'Placeholder' && node.input.length === 0 && node.output.length === 1 && node.controlDependencies.length === 0) {
                 const dtype = node.attr.dtype.type;
                 if (dtype === tf.proto.tensorflow.DataType.DT_RESOURCE) {
-                    return new tf.Value(name, null, tensor);
+                    return this.value(name, null, tensor);
                 }
             }
             return null;
         };
         for (const node of node_map.values()) {
             if (node.op === 'Identity' && node.input.length === 1 && node.output.length === 1 && node.output[0].to.length === 1 && node.controlDependencies.length === 0) {
                 const initializer = map_tensor(node.name, node.input[0].from, 'Identity Constant');
                 if (initializer) {
-                    initializers.set(initializer.name, initializer);
                     node_map.delete(initializer.name);
                     node_map.delete(node.input[0].name);
                 }
                 const identity = node.input[0].from;
                 if (identity && identity.op === 'Identity' && identity.input.length === 1 && identity.output.length === 1 && node.output[0].to.length === 1 && node.controlDependencies.length === 0) {
                     const initializer = map_tensor(node.name, identity.input[0].from, 'Identity Constant');
                     if (initializer) {
-                        initializers.set(initializer.name, initializer);
                         node_map.delete(initializer.name);
                         node_map.delete(initializer.name);
                         node_map.delete(identity.name);
                         node_map.delete(node.name);
                     }
                 }
             }
         }
         for (const node of node_map.values()) {
             const initializer = map_tensor(node.name, node, 'Const');
             if (initializer) {
-                initializers.set(initializer.name, initializer);
                 node_map.delete(node.name);
                 node_map.delete(initializer.name);
             }
         }
         for (const node of node_map.values()) {
             if (node.op === 'ReadVariableOp' && node.input.length === 1 && node.output.length === 1 && node.output[0].to.length === 1 && node.controlDependencies.length === 0) {
                 if (node.attr && node.attr.dtype && node.attr._output_shapes && node.attr._output_shapes.list && node.attr._output_shapes.list.shape) {
                     const tensor = new tf.proto.tensorflow.TensorProto();
                     tensor.dtype = node.attr.dtype.type;
                     tensor.tensor_shape = node.attr._output_shapes.list.shape[0];
                     const name = node.name;
                     const initializer = map_resource(name, node.input[0].from, new tf.Tensor(tensor, name, 'Resource Variable'));
                     if (initializer) {
-                        initializers.set(initializer.name, initializer);
                         node_map.delete(initializer.name);
                         node_map.delete(node.input[0].name);
                     }
                 }
             }
         }
         const input_map = new Map();
         for (const node of node_map.values()) {
             if (node.op == 'Placeholder' && node.input.length === 0 && node.output.length === 1 && node.controlDependencies.length === 0) {
                 const dtype = node.attr.dtype;
                 const shape = node.attr.shape;
                 if (dtype && dtype.type && shape && shape.shape) {
                     const name = node.name;
                     const type = new tf.TensorType(dtype.type, shape.shape);
-                    const value = new tf.Value(name, type, null);
+                    const value = this.value(name, type, null);
                     input_map.set(name, new tf.Argument(name, [value]));
                     node_map.delete(name);
                 }
             }
         }
         const updateTorchScript = (node_map) => {
             for (const node of node_map.values()) {
@@ -2184,23 +2161,21 @@
                         node.value = match[1].trim();
                     }
                 }
                 if (node.op === 'IO Node' && node.controlDependencies.length === 0) {
                     const shape = node.attr && node.attr._output_shapes && node.attr._output_shapes.list && node.attr._output_shapes.list.shape ? node.attr._output_shapes.list.shape[0] : null;
                     const type = shape ? new tf.TensorType('?', shape) : null;
                     if (node.input.length === 0 && node.output.length === 1) {
-                        context.inputs.push(new tf.Argument(node.name, [
-                            new tf.Value(node.output[0].name, type, null)
-                        ]));
+                        const argument = new tf.Argument(node.name, [this.value(node.output[0].name, type, null)]);
+                        this.inputs.push(argument);
                         node_map.delete(node.name);
                     }
                     if (node.input.length === 1 && node.output.length === 0) {
-                        context.outputs.push(new tf.Argument(node.name, [
-                            new tf.Value(node.input[0].name, type, null)
-                        ]));
+                        const argument = new tf.Argument(node.name, [this.value(node.input[0].name, type, null)]);
+                        this.outputs.push(argument);
                         node_map.delete(node.name);
                     }
                 }
                 if (Object.keys(node.attr).length === 2 &&
                     node.attr.attr && node.attr.attr.s && node.attr._output_shapes) {
                     const value = tf.Utility.decodeText(node.attr.attr.s);
                     if (/\s*/.exec(value) || /{\s*}/.exec(value)) {
@@ -2236,16 +2211,15 @@
                     const input = node.input[i];
                     const from = input.from;
                     if (from) {
                         if (from.op === 'prim::GetAttr' && from.input.length === 1 && from.output.length === 1 && from.controlDependencies.length === 0 && from.value !== undefined) {
                             remove_input(input, node);
                             input.label = from.value;
                             const tensor = new tf.Tensor(null, input.name, from.op);
-                            const value = new tf.Value(input.name, null, tensor);
-                            initializers.set(input.name, value);
+                            this.value(input.name, null, tensor);
                         }
                         if (from.op === 'prim::Constant' && from.input.length === 0 && from.controlDependencies.length === 0 && from.value !== undefined) {
                             input.constant = from.value;
                             remove_input(input, node);
                             remove.add(input.name);
                         }
                         if (from.op === 'prim::ListConstruct' && from.output.length === 1 && from.controlDependencies.length === 0 && from.value !== undefined) {
@@ -2406,20 +2380,57 @@
                 if (node.op === 'prim::ListConstruct' && node.remove) {
                     node_map.delete(node.name);
                 }
             }
         };
         updateTorchScript(node_map);
         for (const input of input_map.values()) {
-            context.inputs.push(input);
+            this.inputs.push(input);
         }
         for (const node of node_map.values()) {
-            context.nodes.push(new tf.Node(metadata, node, namespaces, initializers));
+            this.nodes.push(new tf.Node(metadata, node, namespaces, this));
         }
-        return context;
+    }
+};
+
+tf.Utility = class {
+
+    static decodeText(value) {
+        if (typeof value === 'string') {
+            return value;
+        }
+        if (value.length === 0) {
+            return '';
+        }
+        tf.Utility._utf8Decoder = tf.Utility._utf8Decoder || new TextDecoder('utf-8');
+        return tf.Utility._utf8Decoder.decode(value);
+    }
+
+    static dataType(type) {
+        if (!tf.Utility._dataTypes) {
+            const DataType = tf.proto.tensorflow.DataType;
+            const dataTypes = new Map(Object.entries(DataType).map((entry) => {
+                const key = entry[0].startsWith('DT_') ? entry[0].substring(3) : entry[0];
+                return [entry[1], key.toLowerCase()];
+            }));
+            dataTypes.set(DataType.DT_HALF, 'float16');
+            dataTypes.set(DataType.DT_FLOAT, 'float32');
+            dataTypes.set(DataType.DT_DOUBLE, 'float64');
+            dataTypes.set(DataType.DT_BOOL, 'boolean');
+            tf.Utility._dataTypes = dataTypes;
+        }
+        return tf.Utility._dataTypes.has(type) ? tf.Utility._dataTypes.get(type) : '?';
+    }
+
+    static dataTypeKey(type) {
+        if (!tf.Utility._dataTypeKeys) {
+            tf.Utility.dataType(0);
+            tf.Utility._dataTypeKeys = new Map(Array.from(tf.Utility._dataTypes).map((entry) => [entry[1], entry[0]]));
+        }
+        return tf.Utility._dataTypeKeys.get(type);
     }
 };
 
 tf.JsonReader = class {
 
     static decodeGraphDef(json) {
         const message = new tf.proto.tensorflow.GraphDef();
```

## netron/tflite.js

### js-beautify {}

```diff
@@ -26,20 +26,20 @@
         const obj = context.open('json');
         if (obj && obj.subgraphs && obj.operator_codes) {
             return 'tflite.flatbuffers.json';
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         await context.require('./tflite-schema');
         tflite.schema = flatbuffers.get('tflite').tflite;
         let model = null;
         const attachments = new Map();
-        switch (match) {
+        switch (target) {
             case 'tflite.flatbuffers.json': {
                 try {
                     const obj = context.open('json');
                     const reader = new flatbuffers.TextReader(obj);
                     model = tflite.schema.Model.createText(reader);
                 } catch (error) {
                     const message = error && error.message ? error.message : error.toString();
@@ -65,15 +65,15 @@
                     }
                 } catch (error) {
                     // continue regardless of error
                 }
                 break;
             }
             default: {
-                throw new tflite.Error("Unsupported TensorFlow Lite format '" + match + "'.");
+                throw new tflite.Error("Unsupported TensorFlow Lite format '" + target + "'.");
             }
         }
         const metadata = await context.metadata('tflite-metadata.json');
         return new tflite.Model(metadata, model);
     }
 };
```

## netron/tnn.js

### js-beautify {}

```diff
@@ -34,17 +34,17 @@
                     return 'tnn.params';
                 }
             }
         }
         return '';
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const metadata = await context.metadata('tnn-metadata.json');
-        switch (match) {
+        switch (target) {
             case 'tnn.model': {
                 const tnnmodel = context.identifier.substring(0, context.identifier.length - 9) + '.tnnmodel';
                 try {
                     const stream = await context.request(tnnmodel, null);
                     const buffer = stream.peek();
                     return new tnn.Model(metadata, context.stream.peek(), buffer);
                 } catch (error) {
@@ -54,15 +54,15 @@
             case 'tnn.params': {
                 const tnnproto = context.identifier.substring(0, context.identifier.length - 9) + '.tnnproto';
                 const stream = await context.request(tnnproto, null);
                 const buffer = stream.peek();
                 return new tnn.Model(metadata, buffer, context.stream.peek());
             }
             default: {
-                throw new tnn.Error("Unsupported TNN format '" + match + "'.");
+                throw new tnn.Error("Unsupported TNN format '" + target + "'.");
             }
         }
     }
 };
 
 tnn.Model = class {
```

## netron/torch.js

### js-beautify {}

```diff
@@ -2,17 +2,17 @@
 
 torch.ModelFactory = class {
 
     match(context) {
         return torch.T7Reader.open(context);
     }
 
-    async open(context, match) {
+    async open(context, target) {
         const metadata = await context.metadata('torch-metadata.json');
-        const reader = match;
+        const reader = target;
         reader.callback = (name) => {
             if (name && name != 'nn.JointTrainModule' && !name.startsWith('nn.MSDNet_') && !name.startsWith('onmt.')) {
                 context.exception(new torch.Error("Unsupported type '" + name + "'."));
             }
             return null;
         };
         const obj = reader.read();
```

## netron/uff.js

### js-beautify {}

```diff
@@ -22,19 +22,19 @@
             if (tags.has('version') && tags.has('descriptors') && tags.has('graphs')) {
                 return 'uff.pbtxt';
             }
         }
         return undefined;
     }
 
-    async open(context, match) {
+    async open(context, target) {
         await context.require('./uff-proto');
         uff.proto = protobuf.get('uff').uff;
         let meta_graph = null;
-        switch (match) {
+        switch (target) {
             case 'uff.pb': {
                 try {
                     const stream = context.stream;
                     const reader = protobuf.BinaryReader.open(stream);
                     meta_graph = uff.proto.MetaGraph.decode(reader);
                 } catch (error) {
                     const message = error && error.message ? error.message : error.toString();
@@ -49,15 +49,15 @@
                     meta_graph = uff.proto.MetaGraph.decodeText(reader);
                 } catch (error) {
                     throw new uff.Error('File text format is not uff.MetaGraph (' + error.message + ').');
                 }
                 break;
             }
             default: {
-                throw new uff.Error("Unsupported UFF format '" + match + "'.");
+                throw new uff.Error("Unsupported UFF format '" + target + "'.");
             }
         }
         const metadata = await context.metadata('uff-metadata.json');
         return new uff.Model(metadata, meta_graph);
     }
 };
```

## netron/view.js

### js-beautify {}

```diff
@@ -8,31 +8,34 @@
 var flatbuffers = require('./flatbuffers');
 var hdf5 = require('./hdf5');
 var python = require('./python');
 var grapher = require('./grapher');
 
 view.View = class {
 
-    constructor(host, id) {
+    constructor(host) {
         this._host = host;
-        this._id = id ? ('-' + id) : '';
         this._options = {
             weights: true,
             attributes: false,
             names: false,
             direction: 'vertical',
             mousewheel: 'scroll'
         };
-        this._host.view(this).then(() => {
-            this._model = null;
-            this._graphs = [];
-            this._selection = [];
-            this._sidebar = new view.Sidebar(this._host, id);
-            this._searchText = '';
-            this._modelFactoryService = new view.ModelFactoryService(this._host);
+        this._model = null;
+        this._graphs = [];
+        this._selection = [];
+        this._sidebar = new view.Sidebar(this._host);
+        this._searchText = '';
+        this._modelFactoryService = new view.ModelFactoryService(this._host);
+    }
+
+    async start() {
+        try {
+            await this._host.view(this);
             this._element('sidebar-button').addEventListener('click', () => {
                 this.showModelProperties();
             });
             this._element('zoom-in-button').addEventListener('click', () => {
                 this.zoomIn();
             });
             this._element('zoom-out-button').addEventListener('click', () => {
@@ -189,18 +192,18 @@
                     execute: () => this._host.execute('report-issue')
                 });
                 help.add({
                     label: '&About ' + this._host.environment('name'),
                     execute: () => this._host.execute('about')
                 });
             }
-            this._host.start();
-        }).catch((err) => {
+            await this._host.start();
+        } catch (err) {
             this.error(err, null, null);
-        });
+        }
     }
 
     show(page) {
         if (!page) {
             page = (!this._model && !this.activeGraph) ? 'welcome' : 'default';
         }
         this._host.event('screen_view', {
@@ -328,15 +331,15 @@
     _timeout(delay) {
         return new Promise((resolve) => {
             setTimeout(resolve, delay);
         });
     }
 
     _element(id) {
-        return this._host.document.getElementById(id + this._id);
+        return this._host.document.getElementById(id);
     }
 
     zoomIn() {
         this._updateZoom(this._zoom * 1.1);
     }
 
     zoomOut() {
@@ -2152,100 +2155,70 @@
                 break;
         }
     }
 };
 
 view.Sidebar = class {
 
-    constructor(host, id) {
+    constructor(host) {
         this._host = host;
-        this._id = id ? ('-' + id) : '';
         this._stack = [];
-        this._closeSidebarHandler = () => {
-            this._pop();
-        };
+        const pop = () => this._update(this._stack.slice(0, -1));
+        this._closeSidebarHandler = () => pop();
         this._closeSidebarKeyDownHandler = (e) => {
             if (e.keyCode == 27) {
                 e.preventDefault();
-                this._pop();
+                pop();
             }
         };
         const sidebar = this._element('sidebar');
         sidebar.addEventListener('transitionend', (event) => {
             if (event.propertyName === 'opacity' && sidebar.style.opacity === '0') {
                 const content = this._element('sidebar-content');
                 content.innerHTML = '';
             }
         });
     }
 
     _element(id) {
-        return this._host.document.getElementById(id + this._id);
+        return this._host.document.getElementById(id);
     }
 
     open(content, title) {
-        this.close();
-        this.push(content, title);
+        this._update([{
+            title: title,
+            content: content
+        }]);
     }
 
     close() {
-        this._deactivate();
-        this._stack = [];
-        this._hide();
+        this._update([]);
     }
 
     push(content, title) {
-        const item = {
+        this._update(this._stack.concat({
             title: title,
             content: content
-        };
-        this._stack.push(item);
-        this._activate(item);
+        }));
     }
 
-    _pop() {
-        this._deactivate();
-        if (this._stack.length > 0) {
-            this._stack.pop();
-        }
-        if (this._stack.length > 0) {
-            this._activate(this._stack[this._stack.length - 1]);
-        } else {
-            this._hide();
-        }
-    }
-
-    _hide() {
+    _update(stack) {
         const sidebar = this._element('sidebar');
-        if (sidebar) {
-            sidebar.style.right = 'calc(0px - min(calc(100% * 0.6), 42em))';
-            sidebar.style.opacity = 0;
-        }
         const container = this._element('graph');
-        if (container) {
-            container.style.width = '100%';
-            container.focus();
-        }
-    }
-
-    _deactivate() {
-        const sidebar = this._element('sidebar');
-        if (sidebar) {
-            const closeButton = this._element('sidebar-closebutton');
-            closeButton.removeEventListener('click', this._closeSidebarHandler);
-            this._host.document.removeEventListener('keydown', this._closeSidebarKeyDownHandler);
+        const closeButton = this._element('sidebar-closebutton');
+        closeButton.removeEventListener('click', this._closeSidebarHandler);
+        this._host.document.removeEventListener('keydown', this._closeSidebarKeyDownHandler);
+        if (stack) {
+            this._stack = stack;
+        } else if (this._stack.length > 0) {
+            this._stack.pop();
         }
-    }
-
-    _activate(item) {
-        const sidebar = this._element('sidebar');
-        if (sidebar) {
-            const title = this._element('sidebar-title');
-            title.innerHTML = item.title ? item.title.toUpperCase() : '';
-            const closeButton = this._element('sidebar-closebutton');
+        if (this._stack.length > 0) {
+            const item = this._stack[this._stack.length - 1];
+            this._element('sidebar-title').innerHTML = item.title || '';
             closeButton.addEventListener('click', this._closeSidebarHandler);
             const content = this._element('sidebar-content');
             if (typeof item.content == 'string') {
                 content.innerHTML = item.content;
             } else if (item.content instanceof Array) {
                 content.innerHTML = '';
                 for (const element of item.content) {
@@ -2255,18 +2228,20 @@
                 content.innerHTML = '';
                 content.appendChild(item.content);
             }
             sidebar.style.width = 'min(calc(100% * 0.6), 42em)';
             sidebar.style.right = 0;
             sidebar.style.opacity = 1;
             this._host.document.addEventListener('keydown', this._closeSidebarKeyDownHandler);
-        }
-        const container = this._element('graph');
-        if (container) {
             container.style.width = 'max(40vw, calc(100vw - 42em))';
+        } else {
+            sidebar.style.right = 'calc(0px - min(calc(100% * 0.6), 42em))';
+            sidebar.style.opacity = 0;
+            container.style.width = '100%';
+            container.focus();
         }
     }
 };
 
 view.Control = class {
 
     on(event, callback) {
@@ -4947,15 +4922,15 @@
                                     (buffer.some((v) => v === 0x22 || v === 0x5b || v === 0x5d || v === 0x7b || v === 0x7d))) {
                                     const reader = json.TextReader.open(this.stream);
                                     if (reader) {
                                         const obj = reader.read();
                                         this._content.set(type, obj);
                                     }
                                 }
-                            } catch (err) {
+                            } catch (error) {
                                 // continue regardless of error
                             }
                             break;
                         }
                         case 'json.gz': {
                             try {
                                 const archive = zip.Archive.open(this.stream, 'gzip');
@@ -4963,15 +4938,15 @@
                                     const stream = archive.entries.values().next().value;
                                     const reader = json.TextReader.open(stream);
                                     if (reader) {
                                         const obj = reader.read();
                                         this._content.set(type, obj);
                                     }
                                 }
-                            } catch (err) {
+                            } catch (error) {
                                 // continue regardless of error
                             }
                             break;
                         }
                         case 'pkl': {
                             let unpickler = null;
                             try {
@@ -4996,15 +4971,15 @@
                                         if (!torch || !name.startsWith('__torch__.')) {
                                             this.exception(new view.Error("Unknown type name '" + name + "'."));
                                         }
                                     });
                                     const pickle = execution.__import__('pickle');
                                     unpickler = new pickle.Unpickler(data);
                                 }
-                            } catch (err) {
+                            } catch (error) {
                                 // continue regardless of error
                             }
                             if (unpickler) {
                                 unpickler.persistent_load = (saved_id) => saved_id;
                                 const obj = unpickler.load();
                                 this._content.set(type, obj);
                             }
@@ -5288,67 +5263,68 @@
                 throw new view.Error("Archive contains no model files.");
             }
         }
         const json = () => {
             const obj = context.open('json');
             if (obj) {
                 const formats = [{
-                        name: 'Netron metadata',
-                        tags: ['[].name', '[].schema']
-                    }, {
-                        name: 'Netron metadata',
-                        tags: ['[].name', '[].attributes']
-                    }, {
-                        name: 'Netron metadata',
-                        tags: ['[].name', '[].category']
-                    }, {
-                        name: 'Netron test data',
-                        tags: ['[].type', '[].target', '[].source', '[].format', '[].link']
-                    }, {
-                        name: 'Darkflow metadata',
-                        tags: ['net', 'type', 'model']
-                    }, {
-                        name: 'keras-yolo2 configuration',
-                        tags: ['model', 'train', 'valid']
-                    }, {
-                        name: 'Vulkan SwiftShader ICD manifest',
-                        tags: ['file_format_version', 'ICD']
-                    }, {
-                        name: 'DeepLearningExamples configuration',
-                        tags: ['attention_probs_dropout_prob', 'hidden_act', 'hidden_dropout_prob', 'hidden_size', ]
-                    }, {
-                        name: 'NuGet assets',
-                        tags: ['version', 'targets', 'packageFolders']
-                    }, {
-                        name: 'NuGet data',
-                        tags: ['format', 'restore', 'projects']
-                    }, {
-                        name: 'NPM package',
-                        tags: ['name', 'version', 'dependencies']
-                    }, {
-                        name: 'NetworkX adjacency_data',
-                        tags: ['directed', 'graph', 'nodes']
-                    }, {
-                        name: 'Waifu2x data',
-                        tags: ['name', 'arch_name', 'channels']
-                    }, {
-                        name: 'Waifu2x data',
-                        tags: ['[].nInputPlane', '[].nOutputPlane', '[].weight', '[].bias']
-                    }, {
-                        name: 'Brain.js data',
-                        tags: ['type', 'sizes', 'layers']
-                    }, {
-                        name: 'Custom Vision metadata',
-                        tags: ['CustomVision.Metadata.Version']
-                    }, {
-                        name: 'W&B metadata',
-                        tags: ['program', 'host', 'executable']
-                    }
-
-                ];
+                    name: 'Netron metadata',
+                    tags: ['[].name', '[].schema']
+                }, {
+                    name: 'Netron metadata',
+                    tags: ['[].name', '[].attributes']
+                }, {
+                    name: 'Netron metadata',
+                    tags: ['[].name', '[].category']
+                }, {
+                    name: 'Netron test data',
+                    tags: ['[].type', '[].target', '[].source', '[].format', '[].link']
+                }, {
+                    name: 'Darkflow metadata',
+                    tags: ['net', 'type', 'model']
+                }, {
+                    name: 'keras-yolo2 configuration',
+                    tags: ['model', 'train', 'valid']
+                }, {
+                    name: 'Vulkan SwiftShader ICD manifest',
+                    tags: ['file_format_version', 'ICD']
+                }, {
+                    name: 'DeepLearningExamples configuration',
+                    tags: ['attention_probs_dropout_prob', 'hidden_act', 'hidden_dropout_prob', 'hidden_size', ]
+                }, {
+                    name: 'GitHub page data',
+                    tags: ['payload', 'title', 'locale']
+                }, {
+                    name: 'NuGet assets',
+                    tags: ['version', 'targets', 'packageFolders']
+                }, {
+                    name: 'NuGet data',
+                    tags: ['format', 'restore', 'projects']
+                }, {
+                    name: 'NPM package',
+                    tags: ['name', 'version', 'dependencies']
+                }, {
+                    name: 'NetworkX adjacency_data',
+                    tags: ['directed', 'graph', 'nodes']
+                }, {
+                    name: 'Waifu2x data',
+                    tags: ['name', 'arch_name', 'channels']
+                }, {
+                    name: 'Waifu2x data',
+                    tags: ['[].nInputPlane', '[].nOutputPlane', '[].weight', '[].bias']
+                }, {
+                    name: 'Brain.js data',
+                    tags: ['type', 'sizes', 'layers']
+                }, {
+                    name: 'Custom Vision metadata',
+                    tags: ['CustomVision.Metadata.Version']
+                }, {
+                    name: 'W&B metadata',
+                    tags: ['program', 'host', 'executable']
+                }];
                 const match = (obj, tag) => {
                     if (tag.startsWith('[].')) {
                         tag = tag.substring(3);
                         return (Array.isArray(obj) && obj.some((item) => Object.prototype.hasOwnProperty.call(item, tag)));
                     }
                     return Object.prototype.hasOwnProperty.call(obj, tag);
                 };
@@ -5639,18 +5615,18 @@
                 try {
                     const id = modules.shift();
                     const module = await this._host.require(id);
                     if (!module.ModelFactory) {
                         throw new view.Error("Failed to load module '" + id + "'.");
                     }
                     const modelFactory = new module.ModelFactory();
-                    const match = modelFactory.match(context);
-                    if (match) {
+                    const target = modelFactory.match(context);
+                    if (target) {
                         success = true;
-                        const model = await modelFactory.open(context, match);
+                        const model = await modelFactory.open(context, target);
                         if (!model.identifier) {
                             model.identifier = context.identifier;
                         }
                         return model;
                     }
                 } catch (error) {
                     if (context.stream && context.stream.position !== 0) {
@@ -5759,14 +5735,20 @@
                         matches = matches.filter((context) => !context.identifier.toLowerCase().endsWith('.data-00000-of-00001'));
                     }
                     // TensorFlow SavedModel
                     if (matches.length === 2 &&
                         matches.some((context) => context.identifier.toLowerCase().split('/').pop() === 'keras_metadata.pb')) {
                         matches = matches.filter((context) => context.identifier.toLowerCase().split('/').pop() !== 'keras_metadata.pb');
                     }
+                    // Keras
+                    if (matches.length === 2 &&
+                        matches.some((context) => context.identifier.toLowerCase().split('/').pop() === 'config.json') &&
+                        matches.some((context) => context.identifier.toLowerCase().split('/').pop() === 'model.weights.h5')) {
+                        matches = matches.filter((context) => context.identifier.toLowerCase().split('/').pop() == 'model.weights.h5');
+                    }
                     if (matches.length > 1) {
                         throw new view.ArchiveError('Archive contains multiple model files.');
                     }
                     const match = matches.shift();
                     return match;
                 };
                 return await nextEntry();
@@ -5874,24 +5856,22 @@
                 name: 'HTML markup',
                 value: /^\s*<!DOCTYPE\s*HTML\s+(PUBLIC|SYSTEM)?/
             }, {
                 name: 'Unity metadata',
                 value: /^fileFormatVersion:/
             }, {
                 name: 'Python source code',
-                value: /^\s*import[ ]+(os|sys|types|torch|argparse|onnx|numpy|tensorflow)(,|;|\s)/
+                value: /^\s*('''.*''')?\s*import[ ]+[a-zA-Z_]\w*(\.[a-zA-Z_]\w*)*([ ]+as[ ]+[a-zA-Z]\w*)?[ ]*(,|;|\n|\r\n)/
             }, {
                 name: 'Python source code',
-                value: /^\s*import[ ]+([a-z])+[ ]+as[ ]+/
+                value: /^\s*('''.*''')?\s*from[ ]+([a-zA-Z_]\w*(\.[a-zA-Z_]\w*)*)[ ]+import[ ]+[a-zA-Z]\w*[ ]+/
             }, {
-                name: 'Python source code',
-                value: /^\s*from[ ]+(torch)[ ]+import[ ]+/
-            }, {
-                name: 'Python source code',
-                value: /^\s*from[ ]+(keras)[ ]+import[ ]+/
+                name: 'Python virtual environment configuration',
+                value: /^home[ ]*=[ ]*/,
+                identifier: 'pyvenv.cfg'
             }, {
                 name: 'Bash script',
                 value: /^#!\/usr\/bin\/env\s/
             }, {
                 name: 'Bash script',
                 value: /^#!\/bin\/bash\s/
             }, {
```

## netron/zip.js

### js-beautify {}

```diff
@@ -23,72 +23,75 @@
                 }
             }
             if ((!format || format == 'gzip') && buffer.length > 18 && buffer[0] === 0x1f && buffer[1] === 0x8b) { // gzip
                 return new gzip.Archive(stream);
             }
             if (!format || format == 'zip') {
                 const signature = buffer[0] === 0x50 && buffer[1] === 0x4B;
-                const position = stream.position;
+                const location = stream.position;
                 const seek = (content) => {
-                    let position = stream.length;
+                    let index = stream.length;
                     do {
-                        position = Math.max(0, position - 66000);
-                        stream.seek(position);
-                        const length = Math.min(stream.length - position, 66000 + 4);
+                        index = Math.max(0, index - 66000);
+                        stream.seek(index);
+                        const length = Math.min(stream.length - index, 66000 + 4);
                         const buffer = stream.read(length);
                         for (let i = buffer.length - 4; i >= 0; i--) {
                             if (content[0] === buffer[i] && content[1] === buffer[i + 1] && content[2] === buffer[i + 2] && content[3] === buffer[i + 3]) {
-                                stream.seek(position + i + 4);
+                                stream.seek(index + i + 4);
                                 return true;
                             }
                         }
                         if (!signature) {
                             break;
                         }
                     }
-                    while (position > 0);
+                    while (index > 0);
                     return false;
                 };
-                if (!seek([0x50, 0x4B, 0x05, 0x06])) {
-                    stream.seek(position);
-                    if (!signature) {
-                        return null;
-                    }
-                    throw new zip.Error('End of Zip central directory not found.');
-                }
-                const reader = new zip.BinaryReader(stream.read(16));
-                reader.skip(12);
-                let offset = reader.uint32(); // central directory offset
-                if (offset === 0xffffffff || offset > stream.length) {
-                    if (!seek([0x50, 0x4B, 0x06, 0x06])) {
-                        stream.seek(position);
-                        throw new zip.Error('End of Zip64 central directory not found.');
-                    }
+                let offset = -1;
+                let position = -1;
+                if (seek([0x50, 0x4B, 0x06, 0x06])) {
+                    position = stream.position - 4;
                     const reader = new zip.BinaryReader(stream.read(52));
-                    reader.skip(44);
-                    offset = reader.uint64();
+                    reader.skip(36);
+                    position -= reader.uint64(); // size of central directory
+                    offset = reader.uint64(); // central directory offset
                     if (offset === undefined) {
-                        stream.seek(position);
+                        stream.seek(location);
                         throw new zip.Error('Zip 64-bit central directory offset not supported.');
                     }
+                } else if (seek([0x50, 0x4B, 0x05, 0x06])) {
+                    position = stream.position - 4;
+                    const reader = new zip.BinaryReader(stream.read(16));
+                    reader.skip(8);
+                    position -= reader.uint32(); // size of central directory
+                    offset = reader.uint32(); // central directory offset
+                } else {
+                    stream.seek(location);
+                    if (!signature) {
+                        return null;
+                    }
+                    throw new zip.Error('End of Zip central directory not found.');
                 }
-                if (offset > stream.length) {
-                    stream.seek(position);
+                if (position < 0 || position > stream.length) {
+                    stream.seek(location);
                     throw new zip.Error('Invalid Zip central directory offset.');
                 }
-                stream.seek(offset);
-                const archive = new zip.Archive(stream);
                 stream.seek(position);
+                const archive = new zip.Archive(stream, position - offset);
+                stream.seek(location);
                 return archive;
             }
         }
         return null;
     }
 
-    constructor(stream) {
+    constructor(stream, offset) {
+        offset = offset || 0;
         this._entries = new Map();
         const headers = [];
         const signature = [0x50, 0x4B, 0x01, 0x02];
         while (stream.position + 4 < stream.length && stream.read(4).every((value, index) => value === signature[index])) {
             const header = {};
             const reader = new zip.BinaryReader(stream.read(42));
             reader.uint16(); // version made by
@@ -152,29 +155,30 @@
             stream.read(commentLength); // comment
             headers.push(header);
         }
         for (const header of headers) {
             if (header.size === 0 && header.name.endsWith('/')) {
                 continue;
             }
-            const entry = new zip.Entry(stream, header);
+            const entry = new zip.Entry(stream, header, offset);
             this._entries.set(entry.name, entry.stream);
         }
     }
 
     get entries() {
         return this._entries;
     }
 };
 
 zip.Entry = class {
 
-    constructor(stream, header) {
+    constructor(stream, header, offset) {
+        offset = offset || 0;
         this._name = header.name;
-        stream.seek(header.localHeaderOffset);
+        stream.seek(offset + header.localHeaderOffset);
         const signature = [0x50, 0x4B, 0x03, 0x04];
         if (stream.position + 4 > stream.length || !stream.read(4).every((value, index) => value === signature[index])) {
             this._stream = new zip.ErrorStream(header.size, 'Invalid Zip local file header signature.');
         } else {
             const reader = new zip.BinaryReader(stream.read(26));
             reader.skip(22);
             header.nameLength = reader.uint16();
```

## Comparing `netron-7.0.3.dist-info/METADATA` & `netron-7.0.4.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: netron
-Version: 7.0.3
+Version: 7.0.4
 Summary: Viewer for neural network, deep learning, and machine learning models
 Home-page: https://github.com/lutzroeder/netron
 Author: Lutz Roeder
 Author-email: lutzroeder@users.noreply.github.com
 License: MIT
 Keywords: onnx,keras,tensorflow,tflite,coreml,mxnet,caffe,caffe2,torchscript,pytorch,ncnn,mnn,openvino,darknet,paddlepaddle,chainer,artificial intelligence,machine learning,deep learning,neural network,visualizer,viewer
 Classifier: Intended Audience :: Developers
```

## Comparing `netron-7.0.3.dist-info/RECORD` & `netron-7.0.4.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -1,144 +1,144 @@
 netron/__init__.py,sha256=4X_FliRM4GvcwqYDnJ7SHmJoR6u4vdcPBgzfGe62os0,1526
 netron/acuity-metadata.json,sha256=QWN9j-u1qIO3fDekkb81x2htnA2_fBcBza54PmIswYg,57889
-netron/acuity.js,sha256=_r1Rzq1f0PBfRkgCmH8waB3Ueacd6gSnATjcjv7coi8,24158
+netron/acuity.js,sha256=gGKqgzMxq2xrNEtV8IXvNatrEQ57y4TguVSRKIIsa8U,24160
 netron/armnn-metadata.json,sha256=QF244hVPg7xbSSg1EHff8sQCPEKf8-KqGEOHa-AE3io,11340
 netron/armnn-schema.js,sha256=D0drkSXP9KuMls2jd_GipMEgvT2EX_ItpejdUALrCiU,108710
-netron/armnn.js,sha256=Mrqu5ulTFEbN_JF7xs_vlhBSAWFrnIDru4XNAsD6nXc,13841
+netron/armnn.js,sha256=9H9C75YOHvE1mak920MgodkHd1mlV6kRqtvQphNXYak,13844
 netron/barracuda.js,sha256=y_XVrqlaJAMxhVizuxDvf5XHXcOycI0MSP0O-Gtk8ww,16619
 netron/base.js,sha256=e61sbYtfBXDNFrC7px0CVdlgQ2PpMajccjahieDXFJo,38147
 netron/bigdl-metadata.json,sha256=TRtkhMaMeFVOIG7C7sB5cdedbGRifKEQFGQKjqikIBM,2017
 netron/bigdl-proto.js,sha256=i9PTO7r9Z0JktlrmY6n8BIcj1E9AJ7Gc0U_FoZvtcXI,24356
 netron/bigdl.js,sha256=b7rCVWHDOthpjCybe6zERokh1tQ-KQAbp7v8oDm9WuI,12793
-netron/browser.js,sha256=YdHno5zphJaaQ2pWJcxYD_9QqjqBCz0MaudniO1gpTc,33634
+netron/browser.js,sha256=kWpNX4fmqY-W1EVP0XvrX_V7Q3fq6gCLiMUux7UzKns,33629
 netron/caffe-metadata.json,sha256=PfjdGkv0ND0C_RRZTlBp8xU4dbO7IaRVsJswgfS6l-k,9505
 netron/caffe-proto.js,sha256=ffOrbx6VC-rT-hXfFau666KqiP80fpfIzi5IpppkNNw,188897
-netron/caffe.js,sha256=r5mj4-G0F5TNQj3SkT-HNZxlGfc_hfiDQUH0jhg0Cgs,25578
+netron/caffe.js,sha256=bYQbCLtFXEA0Ylu9an48OdDcwEyTKXDHrmo50SWXmdk,25581
 netron/caffe2-metadata.json,sha256=2uApNj06QES26k3krNU4UeLhnhihnLl9un09bd54saI,863689
 netron/caffe2-proto.js,sha256=Tm1juVx6gRP3Vrw0K0WTMN_n_iOIWKCf9UJNou84hyY,61210
-netron/caffe2.js,sha256=oI1ONB00KQZQoeSv1F4V050IwndVPpxz2VToeIB8wkI,22666
+netron/caffe2.js,sha256=SH5h6cZNqTGiHbXsRRcFvmXMhHkYxj9f0d-Unl9k3HA,22669
 netron/cambricon.js,sha256=0DrtZS3ylvm6O1Yx8tiFWXrUopR2bd7sjSI2B9hQJos,902
 netron/circle-metadata.json,sha256=QiCiiauBNSkjeSU4rSayYHNxbnhv9_tuxzKvFvPgJRM,13245
 netron/circle-schema.js,sha256=PP1bNREsniKkUyvI6hG66qI6TrXRnlbhWUw43ZSQaAU,99313
-netron/circle.js,sha256=Re70FOsCu0wfgL3aTZQ7AdC3SNIMmjU7OwPov_3kkLU,24509
+netron/circle.js,sha256=QrrRTZjbEH3jlVXcp0LtHyS6fuimf53dATMHgkk7aPY,24512
 netron/cntk-metadata.json,sha256=XTsJD8M0AvBUS8jYtOS_pfhJsXLNuRdltqy3jnp0Mjc,14193
 netron/cntk-proto.js,sha256=xizxpkzQiIJkJIjRTud0qtY7_yq4q77bvDXWAwCcwmw,11578
-netron/cntk.js,sha256=un8Wr_3gSDZssbiixHuWXRy3m0UM2OwyTCZx7aTzwTQ,43823
+netron/cntk.js,sha256=zhpZY2MvlkROULL57Q4BF0kwIIB3YSyn6BYDIHgbpW8,43826
 netron/coreml-metadata.json,sha256=ZbbnTKcCcZ8b031-9TSGuRMh6V5eurStjmT8h59jSO0,15775
 netron/coreml-proto.js,sha256=3tC_Q_sup8cSzgHzdflSKVz97Ghrkzr1BJAbvCU0HYA,415701
-netron/coreml.js,sha256=cM91w0vDfMBF57w3SjP1AbHMQeZlQW3HnDvzzsQNF0s,67891
+netron/coreml.js,sha256=L3cbKzg_5OSMpyAWWzIhvp3SqvzWkHZKobuNCuwJjhg,67894
 netron/dagre.js,sha256=HqqcEi6GVLwlDZqmqToepYYnpjNEJSGirdNRfEabM9k,102126
 netron/darknet-metadata.json,sha256=dw1vThEJwGVlV74G2cvyzQ6v7LWoGdF_LAnUM77JfXk,20570
-netron/darknet.js,sha256=QojbzexM9mESu18o_2KXvn8Jnn5WOouFflMYem2o758,54921
+netron/darknet.js,sha256=AzXWzMV-X9Qg-HeodXdrwPPdFUPxv6tDnPMz8VNgRPY,54924
 netron/dl4j-metadata.json,sha256=wh1OJVSWT2PQtQRq35NanPXfNF8s0bspM2Ww573U8To,1417
-netron/dl4j.js,sha256=rTPVBzEhrcxIRMlqpFGeT6ToseweotB4sgE_Czq0Exg,17000
+netron/dl4j.js,sha256=OWS2j0HYBK_MQvng0I0pANy7t7UkIcpVrNn45UZNGeA,17003
 netron/dlc-metadata.json,sha256=XIWHz1A0Wvi65Nh5ztVtilFUwZCdxjrGv-0XRTUzQdQ,735
 netron/dlc-schema.js,sha256=5fIESjqcEXdAWfJQGEfJ7nqAvkRcZ3OIEvKG_VZh998,3277
-netron/dlc.js,sha256=jyp7fDz24LznIdax9XGcGbd5fLeBhlrGoCO34ukt2Ic,17868
+netron/dlc.js,sha256=damZ9NWQDolzGt_GogyZW97We3d1lhoQtP1HYqNeNJ8,17870
 netron/dnn-metadata.json,sha256=5-48ChRcuDJQ5WA6_c5xOYs66J3XjsPYbrz7LyH_d9E,1777
 netron/dnn-proto.js,sha256=vpoxH8Jw21cerjYxea6AL1EAfcnO-lhqEjAbJWYu5L0,11533
 netron/dnn.js,sha256=ZGVn8YMbh1JRWRmcCPKHgbOUv3qCmK6uLHcGV0hCRF0,10601
 netron/favicon.ico,sha256=o3hrI04KVfImdrgo9Ucs1f27tMPVjCiJzGogjeR8pHg,34494
 netron/flatbuffers.js,sha256=2IFTatwF8YRtHR-0dO69W5gGxmKgZMc7L8qzPB7zIzI,11358
 netron/flax.js,sha256=qrjY7mxfDamGjpxfscTN8-C0_jYDz9Lx4j8q5Qw6qxU,7734
 netron/flexbuffers.js,sha256=djGSf33a0wTn_3Ux2i7ZO5kJwESfB7WqnEcS2eXRiEI,7568
 netron/flux-metadata.json,sha256=lK6y0flbBJakM3nkhtmqqPtuJrN4D2n9pM_k0MPDR0c,3
 netron/flux.js,sha256=wk8auutcR8pX2X1EeGEYiQWI8bIn_r77O6qYo2tj1OI,2409
 netron/grapher.css,sha256=SEFVqi9GiIiYiZ-HN6vzxoqhBKk14uJrwJaARcvBca4,6061
 netron/grapher.js,sha256=MYfStDExyjpBUDXbP8-LABRUnN-lCQxsIH_cyyGPqyY,25528
 netron/hailo-metadata.json,sha256=RVG-oCGnGid9UOHRdIQ_BINS-GkvG7uyTenguCiKdMs,29456
-netron/hailo.js,sha256=CBaN1nk5C3WOox0Up0JX9HIzHA4ax16CFi1i7SMozY4,11794
+netron/hailo.js,sha256=eNaX5bllMYDOpCdXVJWL7W4MYmka08cfNux_mwDbfDE,11796
 netron/hdf5.js,sha256=-iS1B7LVP_ogiXwyz0GlKh5rxScT8HWSsHl5YakMNK4,57289
-netron/hickle.js,sha256=Vj01PV6oZxF6U8D6bvPhEHCN13gA9QvDzrorYDKEODI,6797
+netron/hickle.js,sha256=WvNNH6BrjXri-hOy5bLUojeCJi_pUE79MjepDNu4mFA,6799
 netron/icon.png,sha256=8PZX7X6-sLBgonyQTGelX60C661x3YZ13eIGcuXQcHc,58106
 netron/imgdnn.js,sha256=PaI-2nhmN96FZbtNSgL34kCx-WE348-oBNgcqecMfmY,1402
-netron/index.html,sha256=su5botDRWhcJ7_cux5NLt1MiTsH6-dF60nS7o-Zdz28,44030
-netron/index.js,sha256=wADnrxaFhXQz69FZpU14AmdrY-k_l6ej3pw_A84TDxo,3797
+netron/index.html,sha256=BvpSZL8xdfIXAcHbj_Mpdd9zIwL6gdPFT5-L2ioA1CE,44057
+netron/index.js,sha256=sGjUrFEQJk93bjbYQ8ULhUJwY9LgNuYqNMuNuMm4cu0,4014
 netron/json.js,sha256=cor_V2_vWltKePIM5OQMvmZRwyl4wsn9vkejf2i4G2c,18643
 netron/keras-metadata.json,sha256=PExbUAIA4PpP35ARwz8Lp66EKfgIuAEY1b2_yWTZzLQ,254682
-netron/keras.js,sha256=4rFFJqBWj930CUA9cWOJLwCDW3uLurU5gjmd8MUBXdY,52693
-netron/kmodel.js,sha256=WVNayL7LAZQ6zGqZBCL3fsCCR1R4v5bNZPkkgT5ctjU,64050
+netron/keras.js,sha256=Y_r2XSQl77DnpWook3b7XO5xz5DgTN5WaFXy8auLqaM,54590
+netron/kmodel.js,sha256=l0zlbLQY2chZCGbQKQpEomsQo3tD7Vv3j7RsRBQAckA,64052
 netron/lasagne-metadata.json,sha256=UAy5q6DnjJWEav_Vo-G-OncwvHVuytNlTStpDJ8MB2U,244
-netron/lasagne.js,sha256=VAldS5uvDXJJ8mYK81GyNyLmx3HwL4DRFTa6F9Y_sDk,7059
-netron/lightgbm.js,sha256=qWxo6iTE4zj96FwaLW75aU1AwHt_vE46XU6Tn1GkASo,5169
+netron/lasagne.js,sha256=1jGqP4NaBDgr-R3HYFldvGZ-LWWF3EZvKS8rZuJef9Y,7061
+netron/lightgbm.js,sha256=50bTm5pbp_va_Cm-Upmdd6DL-XgvvAg_uyQVk6_oNLQ,5172
 netron/mediapipe.js,sha256=dYNcxR8qrRbzDd9s_9mX2JXYYLIHtEwn3A5o7vdU57M,12839
 netron/megengine-metadata.json,sha256=I3m7qRW_yQWJkzNf_XBK6DcxqFcoL-gZvPzSuRzk2Us,91710
 netron/megengine-schema.js,sha256=eZi_wSjkIqR0A0CcXB3gcEqBuKEI14Ug2mTTH0niI9c,82284
-netron/megengine.js,sha256=NbjGPBpawND14iydIpI0KaCd8Gv0J1T4aciQI6M2WaA,32104
+netron/megengine.js,sha256=CC9rAT0pnOGR43XCzA6UFOCnyn6wdJdAfON1VO0GaQE,32109
 netron/mlir.js,sha256=EiR1q4W73kF7h6KKrXOR2tQM0QWIncMapAy_H7zyD7s,44765
 netron/mlnet-metadata.json,sha256=y_pySnY22XYqxvTVdLSEvDLfD76B0UZeB3uZiQp4dys,3423
 netron/mlnet.js,sha256=5RNhieIPdnm1-A0p9zUhMMgS640K-3qQ_NO1DeM1cZ8,78299
 netron/mnn-metadata.json,sha256=ghs-wFIV0Ih-hkeSVP6WJ6djVM6UuVZ4B7saxonOb3E,10058
 netron/mnn-schema.js,sha256=_aveqs9VoXclGp-C6OR2_yNFHhkA4nPBhFiuc_TqH-k,62288
 netron/mnn.js,sha256=jZCYGnnjfeG6M5-JbZikBi8ca4BOvIKlPIKFuUWsYpk,17641
 netron/mslite-metadata.json,sha256=auv76wwLS_Cg4R2t1VXZcUMSUp0louocjSSOXwibMAk,85458
 netron/mslite-schema.js,sha256=-f6KUBaFsKh6q8mJi_8r6ZGK93B6Ih2RKcRRKLsABlA,171745
 netron/mslite.js,sha256=Q1XHky40Y-VaBC-3FxWjCPaZ4GZfYH57losB50-zpCY,14997
 netron/mxnet-metadata.json,sha256=sf1taquijGWKNTAkxVbDMAk4wbkiZ-IYkkYekHxtKfc,11884
-netron/mxnet.js,sha256=kCEyT5FCPRCMsvx4X7f7IbwkB1FNKR50FQ-vJzXTe9g,37800
+netron/mxnet.js,sha256=IR3XwlDzHpZADr_FJHIGFPSYQqLC2BeY5Y1PlEqbImQ,37803
 netron/ncnn-metadata.json,sha256=uokKe5QeTBOjxVo4jcuSMQAFqsm9SXETwWLZlv67JRU,30899
-netron/ncnn.js,sha256=fjHMvjxeScJhDLJL4VOwIgNxR3D7jyoOih28v_dIE3Y,38021
+netron/ncnn.js,sha256=CrklBs2oXxvD4Asp0xIH0zcxyFMaaxdy6HKNsnOfzkM,38024
 netron/nnabla-metadata.json,sha256=fqBPePVmcKoHTp6YAzEpOaSZBrdEUv-SOEUVGM6fJ50,290482
 netron/nnabla-proto.js,sha256=sWfuD9QEF9nRxNfTo4eQSMu8lV5mpmQRJXUkpPIDlrI,434215
-netron/nnabla.js,sha256=WcZWcv1-ZeLucuFOfVjyPQ9xPovt1kujafT3pfdXGvk,11415
-netron/nnef.js,sha256=OomYvZEhWvP4WBNaYwkEWNOCZTvpkZ_KmlAcnnzXYzU,2221
-netron/numpy.js,sha256=1vGC9HdoWabMKnKsEmbafATahGsPdLsQlhWcaapVlRM,15156
+netron/nnabla.js,sha256=lKpVO2UzNuk9ni2CdPQRObAv6twblwHxMfu4hn_Xc6E,11418
+netron/nnef.js,sha256=gOoqFv531ftHkGbC_otlXYE79qAnzkDjDXkCFSGbnt8,2224
+netron/numpy.js,sha256=rFVSNsdTf5NjTCyagrvLgkGhq1Z8X4ElDPf-aZPOn0E,15163
 netron/om-metadata.json,sha256=nWz35Zjqfe_JqM9F9mydQnso0k4j3D1YuKgMJpS8_4Y,53079
 netron/om-proto.js,sha256=1SbZHKiX3S0r98-rX8dGl4bsF7x-DrQDbNxseeunpks,37006
-netron/om.js,sha256=u4v2pKrtEubFbgKi5EVdjjaZ7CrGX56B4rc73CI41xs,31225
+netron/om.js,sha256=1LVRS7DsmfSqpXWPP4fYrA4Fl3lrTRYDG7jCIwNa_68,31227
 netron/onednn-metadata.json,sha256=ZzCrrVEwXx36AWZ_TbOLa6PM-VL4LpEit0u35yj_-LU,6818
-netron/onednn.js,sha256=CDaxY6CO_RAv5uCZ3zMuBV42qqj5z84yovgwQDAmLwY,12045
-netron/onnx-metadata.json,sha256=vMe7QgyBnJSyxVRqJh-S8kj6LYy8j7PnCjwNWaY-nH4,2898410
+netron/onednn.js,sha256=We_25VGJthNLhQrD1HR20N5flwIo5z3SzTgV3A9KDXU,12047
+netron/onnx-metadata.json,sha256=DJeNAQc5H05uK99k5V0C2mnfO7Ea516Np5wr0aRVQ_g,2903924
 netron/onnx-proto.js,sha256=l35_Dhs_wpLvGTuSmWuHsRfXBiJU97JdCA7PzzsvV_s,59899
 netron/onnx-schema.js,sha256=bCJy80ZVAxcNbsa60fBbpJCzOoapMZjf4TnAutaBzqU,15717
-netron/onnx.js,sha256=3u7jkOzUsv76kuUZpkH5gx58LMwiee61ol8NV-dTwRc,83595
+netron/onnx.js,sha256=E-k7pxetvdRA7keyP94YHF85ArairCeNAAXLfsuKAYY,83598
 netron/onnx.py,sha256=GkNnqLXIZjHMviBblu_XorcDKrNcvmVZ0A-Yxg5l2Hg,9053
 netron/openvino-metadata.json,sha256=heC0fS0DL26NLrlVXcEcs4GldF_LYWDBJp2iI1G8_zo,84585
-netron/openvino.js,sha256=JjQ_JwW4DUE7wRtHgaTWnBvC_icExvJgNq4ypTi4nak,44704
+netron/openvino.js,sha256=GrKqOgawHLgKFe3hESkRhm0OndfeRJLOMS1CZXb5BCI,44609
 netron/paddle-metadata.json,sha256=iyV8jUl7AhSOMTVcWLrChsBqS1l8iqGYl99KLYFl93w,2894
 netron/paddle-proto.js,sha256=2vXAa6JSlrxnI7UXYaGwDik4RyaT90QQR7Kc-Kbc5qI,60111
 netron/paddle-schema.js,sha256=DmewWGVK8zHjPz-7GQ6md9WqQsX0sexfw3UizluGedU,19797
-netron/paddle.js,sha256=WL8AJhBjf1KJSRqBehCtNESSwNGMA7b5YMF9-6-54M8,37543
-netron/pickle.js,sha256=-LAx-tIGPioj1_NsjIhjvFPWRespOWhU3ju8Ux0qhDQ,5535
+netron/paddle.js,sha256=9_QmEZvgqWCJ2PfObKjgH09cgxhqNNhgNUfLXDO0n9I,37551
+netron/pickle.js,sha256=x7yo3teKKUaarCpyQ03gZsnDjyJ-ggZW4yOvJvBPnnM,5537
 netron/protobuf.js,sha256=ywdCgnvVRrpARySOloWs_P7e9MliActsCYuqgYZvayM,42713
-netron/python.js,sha256=PANs7FdVRCPXZ2VnNSosH1Wke_c4MWcZvz-imdgJOlA,303137
+netron/python.js,sha256=aaX1cmJZkX697_ow8DfKoY6JO90izXsYKxN3HTT0m4s,303560
 netron/pytorch-metadata.json,sha256=wMK91ihAcneKcpDdg48boEj2Gf4OWl4GzcsIBJizttI,410224
 netron/pytorch-schema.js,sha256=DsFhOphzFGysPeVnnxcqvHgs0zhYy2mTEpBwre8r6IA,13170
-netron/pytorch.js,sha256=zp7qUiKL-6OwBsuM9IZKnABivsgIjnBDvyUWYtqjI2o,182288
+netron/pytorch.js,sha256=CIXK1r27D_LeAr3gJD8mTyA8GSODu47YSSGGeOtTl90,182217
 netron/pytorch.py,sha256=gkEnA4OGqooxARhnsEZfzDYmAsycMSTkLXIB1hMJm9Y,24259
 netron/rknn-metadata.json,sha256=KaVXz6q_TPrAFBaOaSvHhNDU2m-rmeyIl2NThAa7lxY,5473
 netron/rknn-schema.js,sha256=i5gzD6mHjr1jFjTv30mHJk13KErOdaX3O4xSWabkLzE,4263
-netron/rknn.js,sha256=BqDo9WBtrf_u-3Umu7OKX16tRwBJLIh8woYCb2oSs-A,24814
-netron/safetensors.js,sha256=WAl7jOgERk7frrSFeT8zepoD9KYoPRw7B3kvULiJeAI,4569
-netron/server.js,sha256=ySjAW3kiuPqhmkSzEaiT4SEqkNmseljFDU8-MMP1aHE,5970
-netron/server.py,sha256=sjAK8nnHa1Fik3griuhVGPfyG9Xyn719rk8EknznbFk,11874
+netron/rknn.js,sha256=Ox1eKNUIMhUiPVz04VjE7KFBJDm_n_h3sHuraxCkw-w,24816
+netron/safetensors.js,sha256=sNrm4dJlfj5cPKOzMH_IknrxS3juImytbC_2Pl-l9xI,4571
+netron/server.js,sha256=QiQrFtYnWJKpXLmM59Y339DwaCZGqY05RGUhvrQUO3c,5972
+netron/server.py,sha256=A38ZGEWFyknSPTKubCjiCIwFxgKQZWC9XiaahPSzLGo,11874
 netron/sklearn-metadata.json,sha256=L9UWeoEfqkFzZOT4WiupFpVwdDvcuwlXiesuChzqIwc,160693
-netron/sklearn.js,sha256=eqI5Ocf6VKbmCP1FdtBJOQhk6aYT_u8jGm4LmxiAF5M,14707
+netron/sklearn.js,sha256=QPFvFkr6_v25ZhoOsap6Es-CCqdHK8jNDru3CvsQd6I,14713
 netron/tar.js,sha256=0Lr1Ez0QreewNBH2QPq-5oNW63EaeUwwvgov4ypGmFM,4908
 netron/tengine-metadata.json,sha256=v4dIwOf9t_f1bhYkJBORa71SBWlYuwi3LuZZJQjcYGY,27914
-netron/tengine.js,sha256=YoSZeszdMgVI_QN7rU3GPmpCcXGQq0IEFMGyBQFgH_Q,28124
-netron/tensorrt.js,sha256=Ao7johgBZfvS7v9f73JeI5zOc9zKv01ON4bI6CBletk,5330
+netron/tengine.js,sha256=Hd8drHBAtgf7VKv32yYIZYMC-ULUHN_XB5dmvxaaHIA,28126
+netron/tensorrt.js,sha256=g_95J0_u3AvdSb8W17UbwOn1RqtGVpUL3UKSmEnOXRQ,5304
 netron/text.js,sha256=z5u9vVf4wMSITISKa3CqColrXlVYRmiYFNWPgo9ziJ4,11085
 netron/tf-metadata.json,sha256=So93YVb3S4dCJTbySDhaVdhsUqMTCtp-_OZQpCnKXyE,2221625
 netron/tf-proto.js,sha256=b-YUWe3a2eNhVgblSQQISCl_ptEU8EAYiR-T7j0EuT0,361929
-netron/tf.js,sha256=aW1ixEPVyuwZ4woHWBMUkh-H3_CbbBAAJrjxyeo07b0,106255
+netron/tf.js,sha256=jSVYSzxRDJfs5Kos0WAcmSMRNo76DNx5U-boy2RL1CU,106628
 netron/tflite-metadata.json,sha256=sGUxg9ubyeoF1urhm9GjNcqOnXcjRTKgOBbASwWqprs,29780
 netron/tflite-schema.js,sha256=jNEC9GMvUsKb2alsDWKtrgaTuNXb6CsDI_P41Ah13i4,110995
-netron/tflite.js,sha256=pczoEtsxEi4Suv-XYE0HROUs2P8TqZvwQlypQW949Ds,25211
+netron/tflite.js,sha256=m85si-KIZPzVQNeYFu2pf2PF9biIVFbF6EP_WPKrjhw,25214
 netron/tnn-metadata.json,sha256=Je5JnWH0t4gWsSkj9YbWIzzbcYEoP3XXwVMa7sAH3_A,20380
-netron/tnn.js,sha256=SkEeL1Lo4qrs3mdnBZDILvwJ1xRsYYwbQ5tvStg1ORE,26885
+netron/tnn.js,sha256=EgCy_wjzLg9BY8jYiSo7WwxqpEU5qnAgddegS962f9U,26888
 netron/torch-metadata.json,sha256=fj2b1n_Ih7eZdst4ohdUEAL5T3XmjTMlkUBmUo3Ogng,12510
-netron/torch.js,sha256=xwIxlO6eJPLmDfcneR-e4aDI9H1kqhnAT3GMGDVtQ3E,41578
+netron/torch.js,sha256=28XwRQ7IxBoQOpKfOLQMn5eYlmCNKYjIVr1AqYjWdZs,41580
 netron/uff-metadata.json,sha256=kVCe02DZKfSoTgwqfjh18jQcImre1KcYkg76_WNOagI,2333
 netron/uff-proto.js,sha256=U7-KLsLgvBdSeBEclHE8-xaWMqMN_PjoziTOmH7EK9Y,30910
-netron/uff.js,sha256=BiZhuS8SNaR2bKJINIPf2adU2v9eRV1OkeRLSqaQJdw,12802
-netron/view.js,sha256=C_tgSUWn1Y8xRMu--z7D10rm6nN9B1cHTXbG5r0-I9U,235596
+netron/uff.js,sha256=FElkDN7PN_e3jxI7q4wJklGocSYA0TAZzaHrU7iOS24,12805
+netron/view.js,sha256=G9UUPSynH4taFq1q80zjtT-08OCSVhzGifQctAqB33U,235511
 netron/weka.js,sha256=QNhjYBIbmQXB7PBQKLoILyvlT0XOXe5x2VBUc0KQ9bY,8031
 netron/xml.js,sha256=_zng3WkOrLR4OvBYMs0aD04pbmUq6Q2QJQxtETbi2Rw,64034
 netron/xmodel-proto.js,sha256=mFk07nBgAyXBOWllxg-fw-2EGEaIxF231wXlNLK6v5A,55685
 netron/xmodel.js,sha256=FYHJt1B-Ony6vPc_GiGoq9YIkXZyNqrgCfGD3RQTIHg,13916
-netron/zip.js,sha256=xk64acblF603jSKuyy1vE6MdHdZEXDoAmF2yL2neLA0,30503
-netron-7.0.3.dist-info/METADATA,sha256=-wGjS-GAZwqPhG8C_Tkq5kTlBu2S8lXryEMM0TL7xrk,1576
-netron-7.0.3.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-netron-7.0.3.dist-info/entry_points.txt,sha256=3fHM6H_AIEjt21838iCMZ72hmRqtnNTuL66UnCIOSpU,39
-netron-7.0.3.dist-info/top_level.txt,sha256=qt4XhfLsmugdsjAczetcmraULS1GexprL8Ruo2YQubU,7
-netron-7.0.3.dist-info/RECORD,,
+netron/zip.js,sha256=x-6tEIJ_d2gw7Cqipx_mqi_i2wHLfcVb6BR8AenXhLs,30755
+netron-7.0.4.dist-info/METADATA,sha256=kOTAPvKtEwDWQXiG_o8x9Mybw83lYxu_gShIrFt3r8c,1576
+netron-7.0.4.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+netron-7.0.4.dist-info/entry_points.txt,sha256=3fHM6H_AIEjt21838iCMZ72hmRqtnNTuL66UnCIOSpU,39
+netron-7.0.4.dist-info/top_level.txt,sha256=qt4XhfLsmugdsjAczetcmraULS1GexprL8Ruo2YQubU,7
+netron-7.0.4.dist-info/RECORD,,
```

